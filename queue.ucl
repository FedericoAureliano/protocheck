module queue
{
  type op_t    = enum { push, pop };
  type index_t = integer;
  type count_t = integer;
  type data_t  = integer;
  type queue_t = record { 
    contents : [index_t]data_t, 
    head     : index_t, 
    tail     : index_t, 
    count    : count_t, 
    inited   : boolean, 
    valid    : boolean, 
    full     : boolean, 
    empty    : boolean };

  output queue : queue_t;
  input op     : op_t;
  input data   : data_t;

  const SIZE   : integer = 4;
  var curr     : data_t;

  define item_index(i : index_t, q : queue_t) : index_t =
    if ((i + q.head) >= SIZE)
        then (i + q.head) - SIZE
        else (i + q.head);

  define in_queue(v : integer, q : queue_t) : boolean =
    (exists (i : index_t) :: 
        (i >= 0 && i < q.count) && q.contents[item_index(i, q)] == v);

  procedure zero() returns (q : queue_t) {
    q.head   = 0;
    q.tail   = 0;
    q.count  = 0;
    q.valid  = false;
    q.full   = false;
    q.empty  = true;
    q.inited = false;
  }

  procedure pushQ(in_q : queue_t, d: data_t) returns (out_q : queue_t)
    requires !in_q.full;
    requires (in_q.tail >= 0 && in_q.tail < SIZE);
    ensures (out_q.contents == in_q.contents[in_q.tail -> d]);
    ensures (out_q.tail == if (in_q.tail == SIZE-1) then 0 else (in_q.tail + 1));
    ensures (out_q.count == in_q.count + 1);
    ensures (out_q.head == in_q.head);
    ensures (out_q.valid == in_q.valid);
    ensures (out_q.full == in_q.full);
    ensures (out_q.empty == in_q.empty);
    ensures (out_q.inited == in_q.inited);
  {
    out_q.contents = in_q.contents[in_q.tail -> d];
    out_q.tail = in_q.tail + 1;
    if (out_q.tail >= SIZE) { out_q.tail = 0; }
    out_q.count = in_q.count + 1;

    out_q.head = in_q.head;
    out_q.valid = in_q.valid;
    out_q.full = in_q.full;
    out_q.empty = in_q.empty;
    out_q.inited = in_q.inited;
  }

  procedure popQ(in_q : queue_t) returns (out_q : queue_t, popped: data_t)
    requires !in_q.empty;
    requires (in_q.head >= 0 && in_q.head < SIZE);
    ensures (out_q.head == if (in_q.head == SIZE-1) then 0 else (in_q.head + 1));
    ensures (out_q.count == in_q.count - 1);
    ensures (out_q.contents == in_q.contents);
    ensures (out_q.tail == in_q.tail);
    ensures (out_q.valid == in_q.valid);
    ensures (out_q.full == in_q.full);
    ensures (out_q.empty == in_q.empty);
    ensures (out_q.inited == in_q.inited);
    ensures (popped == in_q.contents[in_q.head]);
  {
    out_q.head = in_q.head + 1;
    if (out_q.head >= SIZE) { out_q.head = 0; }
    out_q.count = in_q.count - 1;
    popped = in_q.contents[in_q.head];

    out_q.contents = in_q.contents;
    out_q.tail = in_q.tail;
    out_q.valid = in_q.valid;
    out_q.full = in_q.full;
    out_q.empty = in_q.empty;
    out_q.inited = in_q.inited;
  }

  procedure step(in_q: queue_t, o: op_t, d: data_t) returns (out_q : queue_t, popped: data_t) {
    case
      (o == push && !in_q.full) : {
        call (out_q) = pushQ(in_q, d);
      }
      (o == pop && !in_q.empty) : {
        call (out_q, popped) = popQ(in_q);
      }
      (true) : {
        out_q = in_q;
      }
    esac;
  }

  init {
    call (queue) = zero();
  }

  next {
    call (queue', curr') = step(queue, op, data);
  }

  // count is always between 0 and SIZE.
  invariant[LTL] count_valid: G(queue.count >= 0 && queue.count <= SIZE);

  invariant[LTL] queue_inserts :
    // if we push something
    G((queue.inited && op == push && X(op != pop) && !queue.full)
    // it enters the queue
    ==> X(in_queue(data, queue)));

  invariant[LTL] push_eventually_pops :
    // no push when full
    G(op == push ==> !queue.full)     ==>
    // no pop when empty
    G(op == pop  ==> !queue.empty)    ==>
    // everything that is pushed will eventually be popped.
    G((queue.inited && op == push)    ==>
      F(op == pop && queue.contents[queue.head] == data));

  invariant[LTL] pushed_value_becomes_head :
    // there is always eventually a push
    G(F(op == pop)) ==>
    // every value that is pushed
    G((queue.inited && op == push && !queue.full) ==>
      // eventually becomes the head of the queue
      F(queue.contents[queue.head] == data));

  control {
    vQ    = bmc(4);
    vPush = verify(pushQ);
    vPop  = verify(popQ);
    check;
    print_results;
    vQ.print_cex(curr, op, data, queue);
  }
}
