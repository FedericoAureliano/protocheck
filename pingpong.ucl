module common {
    type event_t = enum { PING, PONG, SUCCESS };
    type state_t = enum { InitEntry, Init, SendPingEntry, SendPing, WaitPing, WaitPong, SendPongEntry, SendPong, Bad};

    // stuff about queues
    type index_t = integer;
    type count_t = integer;
    type queue_t = record { 
        contents : [index_t]event_t, 
        head     : index_t, 
        tail     : index_t, 
        count    : count_t,
        empty    : boolean };

    procedure [inline] zero() returns (q : queue_t) {
        q.head   = 0;
        q.tail   = 0;
        q.count  = 0;
        q.empty  = true;
    }

    procedure [inline] pushQ(in_q : queue_t, d: event_t) returns (out_q : queue_t) {
        out_q.contents = in_q.contents[in_q.tail -> d];
        out_q.head = in_q.head;
        out_q.tail = in_q.tail + 1;
        out_q.count = in_q.count + 1;
        out_q.empty = false;
    }

    procedure [inline] popQ(in_q : queue_t) returns (out_q : queue_t, popped: event_t) 
        requires !in_q.empty;
    {
        out_q.head = in_q.head + 1;
        out_q.tail = in_q.tail;
        out_q.count = in_q.count - 1;
        out_q.empty = out_q.count == 0;

        popped = in_q.contents[in_q.head];
        out_q.contents = in_q.contents;
    }
}

module client {
    // import types
    type state_t = common.state_t;
    type event_t = common.event_t;
    type queue_t = common.queue_t;

    // keep track of the current state
    var state                    : state_t;

    // this is the info we get from the driver
    input external_input_queue   : queue_t;
    input external_output_queue  : queue_t;

    // this is the info we tell the driver
    output internal_input_queue  : queue_t;
    output internal_output_queue : queue_t;

    // we use this to call the common procedures like push, pop, and zero
    instance com : common();

    init {
        state = InitEntry;
        call (internal_input_queue)  = com.zero();
        call (internal_output_queue) = com.zero();
    }

    next {
        case
            (state == InitEntry) : {
                state' = Init;

                // raise success
                call (internal_output_queue') = com.pushQ(external_output_queue, SUCCESS);

                // sync the other queues
                internal_input_queue'  = external_input_queue;

            } (state == Init) : {
                if (!external_input_queue.empty) {
                    // pop off an element of the input queue that the driver gave us
                    // update the internal input queue to reflect this. 
                    // We'll tell the driver about that later
                    var first : event_t;
                    call (internal_input_queue', first) = com.popQ(external_input_queue);

                    if (first == SUCCESS) {
                        state' = SendPingEntry;
                    } else {
                        state' = Bad;
                    }

                    // sync the other queues
                    internal_output_queue'  = external_output_queue;

                } else {
                    // do nothing except sync all queues
                    internal_input_queue'  = external_input_queue;
                    internal_output_queue'  = external_output_queue;
                }

            } (state == SendPingEntry) : {
                var tmp : queue_t;

                state' = SendPing;

                // send a ping
                call (tmp) = com.pushQ(external_output_queue, PING);
                // raise succes
                call (internal_output_queue') = com.pushQ(tmp, SUCCESS);

                // update the other queues
                internal_input_queue'  = external_input_queue;

            } (state == SendPing) : {
                if (!external_input_queue.empty) {
                    var first : event_t;
                    call (internal_input_queue', first) = com.popQ(external_input_queue);
                    if (first == SUCCESS) {
                        state' = WaitPong;
                    } else {
                        state' = Bad;
                    }
                    // update the other queues
                    internal_output_queue'  = external_output_queue;
                } else {
                    // do nothing except sync all queues
                    internal_input_queue'  = external_input_queue;
                    internal_output_queue'  = external_output_queue;
                }

            } (state == WaitPong) : {
                if (!external_input_queue.empty) {
                    var first : event_t;
                    call (internal_input_queue', first) = com.popQ(external_input_queue);
                    if (first == PONG) {
                        state' = SendPingEntry;
                    } else {
                        state' = Bad;
                    }
                    // update the other queues
                    internal_output_queue'  = external_output_queue;
                } else {
                    // do nothing except sync all queues
                    internal_input_queue'  = external_input_queue;
                    internal_output_queue'  = external_output_queue;
                }
            }
        esac;
    }
}

module server {
    // import types
    type state_t = common.state_t;
    type event_t = common.event_t;
    type queue_t = common.queue_t;

    // keep track of the current state
    var state                    : state_t;

    // this is the info we get from the driver
    input external_input_queue   : queue_t;
    input external_output_queue  : queue_t;

    // this is the info we tell the driver
    output internal_input_queue  : queue_t;
    output internal_output_queue : queue_t;

    // we use this to call the common procedures like push, pop, and zero
    instance com : common();

    init {
        state = WaitPing;
        call (internal_input_queue)  = com.zero();
        call (internal_output_queue) = com.zero();
    }

    next {
        case
            (state == SendPongEntry) : {
                var tmp : queue_t;

                state' = SendPong;

                // send a Pong
                call (tmp) = com.pushQ(external_output_queue, PONG);
                // raise succes
                call (internal_output_queue') = com.pushQ(tmp, SUCCESS);

                // update the other queues
                internal_input_queue'  = external_input_queue;

            } (state == SendPong) : {
                if (!external_input_queue.empty) {
                    var first : event_t;
                    call (internal_input_queue', first) = com.popQ(external_input_queue);
                    if (first == SUCCESS) {
                        state' = WaitPong;
                    } else {
                        state' = Bad;
                    }
                    // update the other queues
                    internal_output_queue'  = external_output_queue;
                } else {
                    // do nothing except sync all queues
                    internal_input_queue'  = external_input_queue;
                    internal_output_queue'  = external_output_queue;
                }

            } (state == WaitPing) : {
                if (!external_input_queue.empty) {
                    var first : event_t;
                    call (internal_input_queue', first) = com.popQ(external_input_queue);
                    if (first == PING) {
                        state' = SendPingEntry;
                    } else {
                        state' = Bad;
                    }
                    // update the other queues
                    internal_output_queue'  = external_output_queue;
                } else {
                    // do nothing except sync all queues
                    internal_input_queue'  = external_input_queue;
                    internal_output_queue'  = external_output_queue;
                }
            }
        esac;
    }
}

module main {
    // import types
    type state_t = common.state_t;
    type event_t = common.event_t;
    type queue_t = common.queue_t;

    var client_input_queue          : queue_t;
    var driver_client_input_queue   : queue_t;

    var client_output_queue         : queue_t;
    var driver_client_output_queue  : queue_t;

    var server_input_queue          : queue_t;
    var driver_server_input_queue   : queue_t;

    var server_output_queue         : queue_t;
    var driver_server_output_queue  : queue_t;

    instance c : client(internal_input_queue : (client_input_queue), external_input_queue : (driver_client_input_queue), internal_output_queue : (client_output_queue), external_output_queue : (driver_client_output_queue));
    instance s : server(internal_input_queue : (server_input_queue), external_input_queue : (driver_server_input_queue), internal_output_queue : (server_output_queue), external_output_queue : (driver_server_output_queue));

    instance com : common();

    init {
        call (client_input_queue)         = com.zero();
        call (driver_client_input_queue)  = com.zero();
        call (client_output_queue)        = com.zero();
        call (driver_client_output_queue) = com.zero();

        call (server_input_queue)         = com.zero();
        call (driver_server_input_queue)  = com.zero();
        call (server_output_queue)        = com.zero();
        call (driver_server_output_queue) = com.zero();
    }

    next {
        // TODO decide on composition
        if (*) {
            if (!client_output_queue.empty) {
                var first : event_t;
                call (driver_client_output_queue', first) = com.popQ(client_output_queue);

                // success is a self message, otherwise, send to the server
                if (first == SUCCESS) {
                    call (driver_client_input_queue') = com.pushQ(client_input_queue, SUCCESS);
                    driver_server_output_queue' = server_output_queue;
                    driver_server_input_queue'  = server_input_queue;
                } else {
                    call (driver_server_input_queue') = com.pushQ(server_input_queue, first);
                    driver_client_input_queue'  = client_input_queue;
                    driver_server_output_queue' = server_output_queue;
                }
            } else {
                driver_client_output_queue' = client_output_queue;
                driver_client_input_queue'  = client_input_queue;
                driver_server_output_queue' = server_output_queue;
                driver_server_input_queue'  = server_input_queue;
            }
        } else {
            if (!server_output_queue.empty) {
                var first : event_t;
                call (driver_server_output_queue', first) = com.popQ(server_output_queue);
                
                // success is a self message, otherwise, send to the client
                if (first == SUCCESS) {
                    call (driver_server_input_queue') = com.pushQ(server_input_queue, SUCCESS);
                    driver_client_output_queue' = client_output_queue;
                    driver_client_input_queue'  = client_input_queue;
                } else {
                    call (driver_client_input_queue') = com.pushQ(client_input_queue, first);
                    driver_server_input_queue'  = server_input_queue;
                    driver_client_output_queue' = client_output_queue;
                }
            } else {
                driver_server_output_queue' = server_output_queue;
                driver_server_input_queue'  = server_input_queue;
                driver_client_output_queue' = client_output_queue;
                driver_client_input_queue'  = client_input_queue;
            }
        }
        next(c);
        next(s);
    }

    invariant[LTL] good_client  : G(c.state != Bad);
    invariant[LTL] server_client: G(s.state != Bad);

    control {
        v = bmc(10);
        check;
        print_results;
        v.print_cex(c.state, s.state);
    }
}
