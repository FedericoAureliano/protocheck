module common {
    type event_t = enum { PING, PONG, SUCCESS };
    type state_t = enum { InitEntry, Init, SendPingEntry, SendPing, WaitPing, WaitPong, SendPongEntry, SendPong, Bad};

    // stuff about queues
    type index_t = integer;
    type count_t = integer;
    type queue_t = record { 
        contents : [index_t]event_t, 
        head     : index_t, 
        tail     : index_t, 
        count    : count_t,
        empty    : boolean };

    procedure [inline] zero() returns (q : queue_t) {
        q.head   = 0;
        q.tail   = 0;
        q.count  = 0;
        q.empty  = true;
    }

    procedure [inline] pushQ(in_q : queue_t, d: event_t) returns (out_q : queue_t) {
        out_q.contents = in_q.contents[in_q.tail -> d];
        out_q.head = in_q.head;
        out_q.tail = in_q.tail + 1;
        out_q.count = in_q.count + 1;
        out_q.empty = false;
    }

    procedure [inline] popQ(in_q : queue_t) returns (out_q : queue_t, popped: event_t) 
        requires !in_q.empty;
    {
        out_q.head = in_q.head + 1;
        out_q.tail = in_q.tail;
        out_q.count = in_q.count - 1;
        out_q.empty = out_q.count == 0;

        popped = in_q.contents[in_q.head];
        out_q.contents = in_q.contents;
    }
}

module client {
    // import types
    type state_t = common.state_t;
    type event_t = common.event_t;
    type queue_t = common.queue_t;

    // keep track of the current state
    var state              : state_t;
    sharedvar input_queue  : queue_t;
    sharedvar output_queue : queue_t;

    // we use this to call the common procedures like push, pop, and zero
    instance com : common();

    init {
        state = InitEntry;
        call (input_queue)  = com.zero();
        call (output_queue) = com.zero();
    }

    next {
        case
            (state == InitEntry) : {
                state' = Init;
                call (output_queue') = com.pushQ(output_queue, SUCCESS);
            } (state == Init) : {
                if (!input_queue.empty) {
                    var first : event_t;
                    call (input_queue', first) = com.popQ(input_queue);
                    if (first == SUCCESS) {
                        state' = SendPingEntry;
                    } else {
                        state' = Bad;
                    }
                }
            } (state == SendPingEntry) : {
                var tmp : queue_t;
                state' = SendPing;
                call (tmp) = com.pushQ(output_queue, SUCCESS);
                call (output_queue') = com.pushQ(tmp, PING);

            } (state == SendPing) : {
                if (!input_queue.empty) {
                    var first : event_t;
                    call (input_queue', first) = com.popQ(input_queue);
                    if (first == SUCCESS) {
                        state' = WaitPong;
                    } else {
                        state' = Bad;
                    }
                }
            } (state == WaitPong) : {
                if (!input_queue.empty) {
                    var first : event_t;
                    call (input_queue', first) = com.popQ(input_queue);
                    if (first == PONG) {
                        state' = SendPingEntry;
                    } else {
                        state' = Bad;
                    }
                }
            }
        esac;
    }
}

module server {
    // import types
    type state_t = common.state_t;
    type event_t = common.event_t;
    type queue_t = common.queue_t;

    // keep track of the current state
    var state              : state_t;
    sharedvar input_queue  : queue_t;
    sharedvar output_queue : queue_t;

    // we use this to call the common procedures like push, pop, and zero
    instance com : common();

    init {
        state = WaitPing;
        call (input_queue)  = com.zero();
        call (output_queue) = com.zero();
    }

    next {
        case
            (state == SendPongEntry) : {
                var tmp : queue_t;
                state' = SendPong;
                call (tmp) = com.pushQ(output_queue, SUCCESS);
                call (output_queue') = com.pushQ(tmp, PONG);

            } (state == SendPong) : {
                if (!input_queue.empty) {
                    var first : event_t;
                    call (input_queue', first) = com.popQ(input_queue);
                    if (first == SUCCESS) {
                        state' = WaitPing;
                    } else {
                        state' = Bad;
                    }
                }
            } (state == WaitPing) : {
                if (!input_queue.empty) {
                    var first : event_t;
                    call (input_queue', first) = com.popQ(input_queue);
                    if (first == PING) {
                        state' = SendPongEntry;
                    } else {
                        state' = Bad;
                    }
                }
            }
        esac;
    }
}

module main {
    // import types
    type state_t = common.state_t;
    type event_t = common.event_t;
    type queue_t = common.queue_t;

    var client_input_queue  : queue_t;
    var client_output_queue : queue_t;
    var server_input_queue  : queue_t;
    var server_output_queue : queue_t;

    instance c : client(input_queue : (client_input_queue), output_queue : (client_output_queue));
    instance s : server(input_queue : (server_input_queue), output_queue : (server_output_queue));

    instance com : common();

    init {
        call (client_input_queue)  = com.zero();
        call (client_output_queue) = com.zero();
        call (server_input_queue)  = com.zero();
        call (server_output_queue) = com.zero();
    }

    next {
        if (*) {
            next(c);
            next(s);
        } else {
            if (*) {
                if (!client_output_queue.empty) {
                    var first : event_t;
                    var tmp   : queue_t;

                    call (client_output_queue', first) = com.popQ(client_output_queue);

                    // success is a self message, otherwise, send to the server
                    if (first == SUCCESS) {
                        call (client_input_queue') = com.pushQ(client_input_queue, SUCCESS);
                    } else {
                        call (server_input_queue') = com.pushQ(server_input_queue, first);
                    }
                }
            } else {
                if (!server_output_queue.empty) {
                    var first : event_t;
                    var tmp   : queue_t;

                    call (server_output_queue', first) = com.popQ(server_output_queue);
                    
                    // success is a self message, otherwise, send to the client
                    if (first == SUCCESS) {
                        call (server_input_queue') = com.pushQ(server_input_queue, SUCCESS);
                    } else {
                        call (client_input_queue') = com.pushQ(client_input_queue, first);
                    }
                }
            }
        }
    }

    invariant[LTL] good_client : G(c.state != Bad);
    invariant[LTL] good_server : G(s.state != Bad);

    control {
        v = bmc(10);
        check;
        print_results;
        v.print_cex(
            c.state,
            client_input_queue.count,
            client_input_queue.contents[client_input_queue.head],

            s.state,
            server_input_queue.count,
            server_input_queue.contents[server_input_queue.head]
        );
    }
}
