module main {

    type machine_id = integer;

    // events
    type signal_t = enum { PING, PONG, SUCCESS };
    type event_t  = record {
        signal: signal_t,
        source: machine_id,
        target: machine_id
    };

    // states
    type state_e = enum { Init, SendPing, WaitPing, WaitPong, SendPong, Bad};
    type state_t = record {
        name : state_e,
        entry: boolean
    };

    // event queues
    type event_id      = integer;
    type count_t       = integer;
    type event_queue_t = record { 
        data: [event_id]event_t,
        head: event_id, 
        tail: event_id,
        size: count_t
    };

    // machines
    type kind_t    = enum { Client, Server };
    type machine_t = record {
        alive: boolean,
        kind : kind_t,
        state: state_t
    };

    // machine lists
    type machine_list_t = record { 
        data   : [machine_id]machine_t,
        count  : machine_id,
        events : event_queue_t
    };

    // procedures for event queues
    procedure [inline] resetEvents() 
        modifies machines;
    {
        machines.events.head = 0;
        machines.events.tail = 0;
        machines.events.size = 0;
    }

    procedure [inline] pushEvent(event_push: event_t) 
        modifies machines;
    {
        machines.events.data = machines.events.data[machines.events.tail -> event_push];
        machines.events.tail = machines.events.tail + 1;
        machines.events.size = machines.events.size + 1;
    }

    procedure [inline] popEvent() 
        returns (event_pop: event_t)
        modifies machines; 
    {
        event_pop = machines.events.data[machines.events.head];
        machines.events.head = machines.events.head + 1;
        machines.events.size = machines.events.size - 1;
    }

    //  procedures for machine lists
    procedure [inline] resetMachines() 
        modifies machines;
    {
        machines.count = 0;
    }

    procedure [inline] addMachine(machine_add: machine_t) 
        modifies machines; 
    {
        machines.data  = machines.data[machines.count -> machine_add];
        machines.count = machines.count + 1;
    }

    procedure [inline] deleteMachine(id_delete: machine_id) 
        modifies machines;
    {
        var tmp_delete : machine_t;

        tmp_delete       = machines.data[id_delete];
        tmp_delete.alive = false;
        machines.data    = machines.data[id_delete -> tmp_delete];
    }

    // procedures for the model
    procedure [inline] initMachines() 
        modifies machines;
    {
        var client_init: machine_t;

        call ()            = resetMachines();
        call ()            = resetEvents();
        call (client_init) = createClient();
        call ()            = addMachine(client_init);
    }

    procedure [inline] createClient() 
        returns (client_create: machine_t)
    {
        client_create.alive       = true;
        client_create.kind        = Client;
        client_create.state.name  = Init;
        client_create.state.entry = true;
    }

    procedure [inline] createServer() 
        returns (server_create: machine_t)
    {
        server_create.alive       = true;
        server_create.kind        = Server;
        server_create.state.name  = WaitPing;
    }

    procedure [inline] clientInit(client_init_event: event_t) 
        modifies machines;
        requires machines.data[client_init_event.target].kind == Client;
        requires machines.data[client_init_event.target].state.name == Init;
        requires !machines.data[client_init_event.target].state.entry;
    {
        var tmp_client_init : machine_t;
        tmp_client_init = machines.data[client_init_event.target];

        if (client_init_event.signal == SUCCESS) {
            tmp_client_init.state.entry = true;
            tmp_client_init.state.name = SendPing;
        } else {
            tmp_client_init.state.name = Bad;
        }

        machines.data = machines.data[client_init_event.target -> tmp_client_init];
    }

    procedure [inline] clientSendPing(client_send_ping_event: event_t) 
        modifies machines;
        requires machines.data[client_send_ping_event.target].kind == Client;
        requires machines.data[client_send_ping_event.target].state.name == SendPing;
        requires !machines.data[client_send_ping_event.target].state.entry;
    {
        var tmp_client_send_ping : machine_t;
        tmp_client_send_ping = machines.data[client_send_ping_event.target];

        if (client_send_ping_event.signal == SUCCESS) {
            tmp_client_send_ping.state.entry = true;
            tmp_client_send_ping.state.name = WaitPong;
        } else {
            tmp_client_send_ping.state.name = Bad;
        }

        machines.data = machines.data[client_send_ping_event.target -> tmp_client_send_ping];
    }

    procedure [inline] clientWaitPong(client_wait_pong_event: event_t) 
        modifies machines;
        requires machines.data[client_wait_pong_event.target].kind == Client;
        requires machines.data[client_wait_pong_event.target].state.name == WaitPong;
    {
        var tmp_client_wait_pong : machine_t;
        tmp_client_wait_pong = machines.data[client_wait_pong_event.target];

        if (client_wait_pong_event.signal == PONG) {
            tmp_client_wait_pong.state.entry = true;
            tmp_client_wait_pong.state.name = SendPing;
        } else {
            tmp_client_wait_pong.state.name = Bad;
        }

        machines.data = machines.data[client_wait_pong_event.target -> tmp_client_wait_pong];
    }

    procedure [inline] serverSendPong(server_send_pong_event: event_t) 
        modifies machines;
        requires machines.data[server_send_pong_event.target].kind == Server;
        requires machines.data[server_send_pong_event.target].state.name == SendPong;
        requires !machines.data[server_send_pong_event.target].state.entry;
    {
        var tmp_server_send_pong : machine_t;
        tmp_server_send_pong = machines.data[server_send_pong_event.target];

        if (server_send_pong_event.signal == SUCCESS) {
            tmp_server_send_pong.state.entry = true;
            tmp_server_send_pong.state.name = WaitPing;
        } else {
            tmp_server_send_pong.state.name = Bad;
        }

        machines.data = machines.data[server_send_pong_event.target -> tmp_server_send_pong];
    }

    procedure [inline] serverWaitPing(server_wait_ping_event: event_t) 
        modifies machines;
        requires machines.data[server_wait_ping_event.target].kind == Server;
        requires machines.data[server_wait_ping_event.target].state.name == WaitPing;
    {
        var tmp_server_wait_ping : machine_t;
        tmp_server_wait_ping = machines.data[server_wait_ping_event.target];

        if (server_wait_ping_event.signal == PING) {
            tmp_server_wait_ping.state.entry = true;
            tmp_server_wait_ping.state.name = SendPong;
        } else {
            tmp_server_wait_ping.state.name = Bad;
        }

        machines.data = machines.data[server_wait_ping_event.target -> tmp_server_wait_ping];
    }

    procedure [inline] clientInitEntry(client_init_entry_id: machine_id) 
        modifies machines;
        requires machines.data[client_init_entry_id].kind == Client;
        requires machines.data[client_init_entry_id].state.name == Init;
        requires machines.data[client_init_entry_id].state.entry;
    {
        var init_success_event    : event_t;
        var new_server            : machine_t;
        var tmp_client_init_entry : machine_t;

        tmp_client_init_entry = machines.data[client_init_entry_id];
        tmp_client_init_entry.state.entry = false;

        init_success_event.signal = SUCCESS;
        init_success_event.source = client_init_entry_id;
        init_success_event.target = client_init_entry_id;

        call ()           = pushEvent(init_success_event);
        call (new_server) = createServer();
        call ()           = addMachine(new_server);

        machines.data = machines.data[client_init_entry_id -> tmp_client_init_entry];
    }

    procedure [inline] clientSendPingEntry(send_ping_source_id: machine_id, send_ping_target_id: machine_id) 
        modifies machines;
        requires machines.data[send_ping_source_id].kind == Client;
        requires machines.data[send_ping_source_id].state.name == SendPing;
        requires machines.data[send_ping_source_id].state.entry;
    {
        var send_ping_success_event : event_t;
        var send_ping_event         : event_t;
        var tmp_send_ping           : machine_t;

        tmp_send_ping             = machines.data[send_ping_source_id];
        tmp_send_ping.state.entry = false;

        send_ping_success_event.signal = SUCCESS;
        send_ping_success_event.source = send_ping_source_id;
        send_ping_success_event.target = send_ping_source_id;
        call () = pushEvent(send_ping_success_event);

        send_ping_event.signal = PING;
        send_ping_event.source = send_ping_source_id;
        send_ping_event.target = send_ping_target_id;
        call () = pushEvent(send_ping_event);

        machines.data = machines.data[send_ping_source_id -> tmp_send_ping];
    }

    procedure [inline] serverSendPongEntry(send_pong_source_id: machine_id, send_pong_target_id: machine_id) 
        modifies machines;
        requires machines.data[send_pong_source_id].kind == Server;
        requires machines.data[send_pong_source_id].state.name == SendPong;
        requires machines.data[send_pong_source_id].state.entry;
    {
        var send_pong_success_event : event_t;
        var send_pong_event         : event_t;
        var tmp_send_pong           : machine_t;

        tmp_send_pong             = machines.data[send_pong_source_id];
        tmp_send_pong.state.entry = false;

        send_pong_success_event.signal = SUCCESS;
        send_pong_success_event.source = send_pong_source_id;
        send_pong_success_event.target = send_pong_source_id;
        call () = pushEvent(send_pong_success_event);

        send_pong_event.signal = PONG;
        send_pong_event.source = send_pong_source_id;
        send_pong_event.target = send_pong_target_id;
        call () = pushEvent(send_pong_event);

        machines.data = machines.data[send_pong_source_id -> tmp_send_pong];
    }

    procedure [inline] act() 
        modifies machines;
    {
        var s: machine_id;
        assume(s >= 0 && s < machines.count && machines.data[s].alive);

        case 
            (machines.data[s].kind == Client): {
                case
                    (machines.data[s].state.name == Init): {
                        if (machines.data[s].state.entry) {
                            call () = clientInitEntry(s);
                        }
                    }
                    (machines.data[s].state.name == SendPing): {
                        if (machines.data[s].state.entry) {
                            var t: machine_id;
                            assume(t >= 0 && t < machines.count && machines.data[t].alive && t != s);
                            call () = clientSendPingEntry(s, t);
                        }
                    }
                (true) : {
                    // do nothings
                }
                esac
            }
            (machines.data[s].kind == Server): {
                case
                    (machines.data[s].state.name == SendPong): {
                        if (machines.data[s].state.entry) {
                            var t: machine_id;
                            assume(t >= 0 && t < machines.count && machines.data[t].alive && t != s);
                            call () = serverSendPongEntry(s, t);
                        }
                    }
                (true) : {
                    // do nothings
                }
                esac
            }
        (true) : {
            // do nothings
        }
        esac
    }

    procedure [inline] react() 
        modifies machines;
    {
        var e  : event_t;

        call (e) = popEvent();

        // case switch on every state of the entire system
        case 
        (machines.data[e.target].kind == Client) : {
            case 
            (machines.data[e.target].state.name == Init) : {
                if (!machines.data[e.target].state.entry) {
                    call () = clientInit(e);
                }
            }
            (machines.data[e.target].state.name == WaitPong) : {
                call () = clientWaitPong(e);
            }
            (machines.data[e.target].state.name == SendPing) : {
                if (!machines.data[e.target].state.entry) {
                    call () = clientSendPing(e);
                }
            }
            (true) : {
                // do nothing
            }
            esac
        } 
        (machines.data[e.target].kind == Server) : {
            case 
            (machines.data[e.target].state.name == WaitPing) : {
                call () = serverWaitPing(e);
            }
            (machines.data[e.target].state.name == SendPong) : {
                if (!machines.data[e.target].state.entry) {
                    call () = serverSendPong(e);
                }
            }
            (true) : {
                // do nothing
            }
            esac
        }
        (true) : {
            // do nothing
        }
        esac
    }

    var machines: machine_list_t;

    init {
        call () = initMachines();
    }

    next {
        if (*) {
            call () = act();
        } else {
            assume(machines.events.size > 0);
            call () = react();
        }
    }

    // MAIN INVARIANT
    invariant never_bad: 
        forall (id: machine_id) :: (id >= 0 && id < machines.count && machines.data[id].alive) ==> 
            machines.data[id].state.name != Bad;

    // AUXILLARY INVARIANTS

    // first machine is client, second is server, if it exists
    invariant two_machines_not_in_init_entry_or_one_client_in_init_entry:
        (machines.count == 1 && 
         machines.data[0].state.name == Init &&
         machines.data[0].state.entry &&
         machines.data[0].kind == Client && 
         machines.data[0].alive)
        ||
        (machines.count == 2 && 
         (machines.data[0].state.name != Init || !machines.data[0].state.entry) &&
         machines.data[0].kind == Client && 
         machines.data[0].alive &&
         machines.data[1].kind == Server &&
         machines.data[1].alive
         );
    
    invariant max_two_events: machines.events.size <= 2;
    invariant min_zero_events: machines.events.size >= 0;
    invariant coherent_events: 
        machines.events.size == machines.events.tail - machines.events.head;

    // every target exists 
    invariant existing_target: 
        forall (x : event_id) :: 
            (x >= machines.events.head && x < machines.events.tail) ==>
            (machines.events.data[x].target >= 0 && machines.events.data[x].target < machines.count);

    // client is in Init, SendPing, or WaitPong
    invariant client_states: 
        machines.data[0].state.name == Init ||
        machines.data[0].state.name == SendPing ||
        machines.data[0].state.name == WaitPong;

    // server is in SendPong, or WaitPing, if it exists
    invariant server_states:
        machines.count == 2 ==> 
        (machines.data[1].state.name == SendPong ||
        machines.data[1].state.name == WaitPing);

    invariant cant_both_send: 
        machines.data[0].state.name != SendPing || 
        machines.data[1].state.name != SendPong;

    // If the client is in init, then the server is in WaitPing, if it exists
    invariant client_init:
        machines.data[0].state.name == Init ==>
        (machines.count == 2 ==> 
        machines.data[1].state.name == WaitPing);

    // If the client is in init entry, then the server doesn't exist and events are empty
    invariant client_init_entry:
        (machines.data[0].state.name == Init && 
        machines.data[0].state.entry) ==>
        (machines.count == 1 &&
        machines.events.size == 0);

    // If the client is in init but not entry, then the server exists and success is the only event
    invariant client_init_success:
        (machines.data[0].state.name == Init && 
        !machines.data[0].state.entry) ==>
        (machines.count == 2 &&
        machines.events.size == 1 &&
        machines.events.data[machines.events.head].signal == SUCCESS &&
        machines.events.data[machines.events.head].target == 0);

    // If the client is in SendPing entry then there are no events 
    invariant client_send_ping_entry:
        (machines.data[0].state.name == SendPing &&
        machines.data[0].state.entry) ==>
        machines.events.size == 0;

    // If the client is in SendPing not entry and the server is in WaitPing, then there are two events: success and ping 
    invariant client_send_ping_not_entry:
        (machines.data[0].state.name == SendPing &&
        !machines.data[0].state.entry &&
        machines.data[1].state.name == WaitPing) ==>
        (machines.events.size == 2 && 
        machines.events.data[machines.events.head].signal == SUCCESS &&
        machines.events.data[machines.events.head].target == 0 &&
        machines.events.data[machines.events.head + 1].signal == PING &&
        machines.events.data[machines.events.head + 1].target == 1);

    // If the client is waiting for a pong, then there is a single pong event or a success before it
    invariant client_wait_pong:
        machines.data[1].state.name == WaitPong ==>
        (machines.events.size == 2 ==>
        (machines.events.data[machines.events.head].signal == SUCCESS &&
        machines.events.data[machines.events.head].target == 1 &&
        machines.events.data[machines.events.head + 1].signal == PONG &&
        machines.events.data[machines.events.head + 1].target == 0));

    // If the server is in SendPong entry then there are no events 
    invariant server_send_pong_entry:
        (machines.data[1].state.name == SendPong &&
        machines.data[1].state.entry) ==>
        machines.events.size == 0;

    // If the server is in SendPong not entry and the client is in WaitPong, then there are two events: success and ping 
    invariant server_send_pong_not_entry:
        (machines.data[1].state.name == SendPong &&
        !machines.data[1].state.entry &&
        machines.data[0].state.name == WaitPong) ==>
        (machines.events.size == 2 && 
        machines.events.data[machines.events.head].signal == SUCCESS &&
        machines.events.data[machines.events.head].target == 1 &&
        machines.events.data[machines.events.head + 1].signal == PONG &&
        machines.events.data[machines.events.head + 1].target == 0);

    // If the server is waiting for a ping, then there is a single ping event or a success before it
    invariant server_wait_ping:
        machines.data[1].state.name == WaitPing ==>
        (machines.events.size == 2 ==>
        (machines.events.data[machines.events.head].signal == SUCCESS &&
        machines.events.data[machines.events.head].target == 0 &&
        machines.events.data[machines.events.head + 1].signal == PING &&
        machines.events.data[machines.events.head + 1].target == 1));

    invariant wait_wait_1: 
        machines.data[0].state.name == WaitPong &&
        machines.data[1].state.name == WaitPing ==>
        (machines.events.size == 1 &&
        ((machines.events.data[machines.events.head].signal == PING &&
        machines.events.data[machines.events.head].target == 1) ||
        ((machines.events.data[machines.events.head].signal == PONG &&
        machines.events.data[machines.events.head].target == 0))));

    control {
        v = induction;
        check;
        print_results;

        v.print_cex(
            machines.count,

            machines.events.size,
            machines.events.data[machines.events.head].signal,
            machines.events.data[machines.events.head].target,
            machines.events.data[machines.events.head+1].signal,
            machines.events.data[machines.events.head+1].target,

            machines.data[0].kind,
            machines.data[0].state.name,
            machines.data[0].state.entry,

            machines.data[1].kind,
            machines.data[1].state.name,
            machines.data[1].state.entry
        );
    }
}