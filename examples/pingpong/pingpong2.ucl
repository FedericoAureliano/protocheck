module main {
    // *** TYPE DECLARATIONS ***
    type machine_id = integer;

    // events
    type signal_t = enum { PING, PONG, SUCCESS };
    type event_t  = record {
        signal: signal_t,
        source: machine_id,
        target: machine_id
    };

    // states
    type state_e = enum { Init, SendPing, WaitPing, WaitPong, SendPong, Bad};
    type state_t = record {
        name : state_e,
        entry: boolean
    };

    // event queues
    type event_id      = integer;
    type count_t       = integer;
    type event_queue_t = record { 
        data: [event_id]event_t,
        head: event_id, 
        tail: event_id,
        size: count_t
    };

    // machines
    type kind_t    = enum { Client, Server };
    type machine_t = record {
        id   : machine_id,
        alive: boolean,
        kind : kind_t,
        state: state_t,
        out  : event_queue_t
    };

    // machine queues
    type machine_list_t = record { 
        data : [machine_id]machine_t,
        count: integer
    };

    // *** PROCEDURE DECLARATIONS ***
    // procedures for event queues
    procedure [inline] resetEvents() 
        returns (q: event_queue_t) 
    {
        q.head  = 0;
        q.tail  = 0;
        q.size = 0;
    }

    procedure [inline] pushEvent(x: event_queue_t, d: event_t) 
        returns (y: event_queue_t) 
    {
        y.data  = x.data[x.tail -> d];
        y.head  = x.head;
        y.tail  = x.tail + 1;
        y.size = x.size + 1;
    }

    procedure [inline] popEvent(x: event_queue_t) 
        returns (y: event_queue_t, popped: event_t) 
        requires x.size > 0;
    {
        y.head  = x.head + 1;
        y.tail  = x.tail;
        y.size = x.size - 1;

        popped = x.data[x.head];
        y.data = x.data;
    }

    //  MACHINES
    procedure [inline] addMachine(x: machine_list_t, d: machine_t) 
        returns (y: machine_list_t) 
        requires d.alive;
        ensures y.count == x.count + 1;
    {
        y = x;

        y.data = x.data[x.count -> d];
        y.count = x.count + 1;
    }

    procedure [inline] getMachine(x: machine_list_t, id: machine_id) 
        returns (m: machine_t) 
        requires x.count > 0;
        requires m.alive;
        ensures m.id == id;
    {
        m = x.data[id];
    }

    procedure [inline] deleteMachine(x: machine_list_t, id: machine_id) 
        returns (y: machine_list_t)
        requires x.count > 0;
        requires x.data[id].alive;
        ensures !y.data[id].alive;
    {
        var m: machine_t;

        m = x.data[id];

        m.alive = false;
        y.data  = x.data[id -> m];
    }

    procedure [inline] initMachines() 
        returns (y: machine_list_t)
        ensures y.count == 1;
        ensures y.data[0].alive;
        ensures y.data[0].kind == Client;
        ensures y.data[0].state.name == Init;
        ensures y.data[0].state.entry;
        ensures y.data[0].out.size == 0;
    {
        var client: machine_t;
        var tmp   : machine_list_t;

        tmp.count = 0;

        call (client) = createClient(tmp.count);
        call (y)      = addMachine(tmp, client);
    }

    procedure [inline] createClient(id: machine_id) 
        returns (c: machine_t) 
    {
        c.id          = id;
        c.alive       = true;
        c.kind        = Client;
        c.state.name  = Init;
        c.state.entry = true;
        call (c.out)  = resetEvents();
    }

    procedure [inline] createServer(id: machine_id) 
        returns (s: machine_t) 
    {
        s.id          = id;
        s.alive       = true;
        s.kind        = Server;
        s.state.name  = WaitPing;
        s.state.entry = true;
        call (s.out)  = resetEvents();
    }

    procedure [inline] clientInitEntry(id: machine_id, x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.data[id].alive;
        requires x.data[id].kind == Client; 
        requires x.data[id].state.name == Init; 
        requires x.data[id].state.entry;
        ensures y.data[id].alive;
        ensures y.data[id].kind == Client; 
        ensures y.data[id].state.name == Init; 
        ensures !y.data[id].state.entry;
        ensures y.count == x.count + 1;
    {
        var success: event_t;
        var server : machine_t;
        var client : machine_t;

        client = x.data[id];
        y      = x;

        success.signal = SUCCESS;
        success.source = client.id;
        success.target = client.id;

        call (client.out) = pushEvent(client.out, success);
        call (server)     = createServer(x.count); // bug in UCLID when x is replaced by y?
        call (y)          = addMachine(x, server);

        client.state.entry = false;

        y.data = y.data[id -> client];
    }

    procedure [inline] clientSendPingEntry(id: machine_id, x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.data[id].alive;
        requires x.data[id].kind == Client;
        requires x.data[id].state.name == SendPing; 
        requires x.data[id].state.entry;
        ensures y.data[id].alive;
        ensures y.data[id].kind == Client;
        ensures y.data[id].state.name == SendPing; 
        ensures !y.data[id].state.entry;
        ensures y.count == x.count;
        // ensures y.data[id].data[y.data[id].head].signal == PING; //bug in UCLID?
    {
        var success: event_t;
        var ping   : event_t;
        var client : machine_t;
        var tmp    : machine_t;

        tmp = x.data[id];

        success.signal = SUCCESS;
        success.source = client.id;
        success.target = client.id;
        call (tmp.out) = pushEvent(x.data[id].out, success);

        client = tmp;

        ping.signal       = PING;
        ping.source       = client.id;
        ping.target       = client.id + 1; // better way to do this?
        call (client.out) = pushEvent(tmp.out, ping);

        client.state.entry = false;

        y = x;
        y.data = x.data[id -> client];
    }

    procedure [inline] serverSendPongEntry(id: machine_id, x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.data[id].alive;
        requires x.data[id].kind == Server;
        requires x.data[id].state.name == SendPong;
        requires x.data[id].state.entry;
        ensures y.data[id].alive;
        ensures y.data[id].kind == Server;
        ensures y.data[id].state.name == SendPong;
        ensures !y.data[id].state.entry;
        ensures y.count == x.count;
        // ensures y.data[id].data[y.data[id].head].signal == PONG; //bug in UCLID?
    {
        var success: event_t;
        var pong   : event_t;
        var server : machine_t;
        var tmp    : machine_t;

        tmp = x.data[id];

        success.signal = SUCCESS;
        success.source = server.id;
        success.target = server.id;
        call (tmp.out) = pushEvent(x.data[id].out, success);

        server = tmp;

        pong.signal       = PONG;
        pong.source       = server.id;
        pong.target       = server.id - 1; // better way to do this?
        call (server.out) = pushEvent(tmp.out, pong);

        server.state.entry = false;

        y = x;
        y.data = x.data[id -> server];
    }

    procedure [inline] actions(x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.count > 0;
        ensures y.count > 0;
    {
        var choice: machine_id;
        assume(choice >= 0 && choice < x.count && x.data[choice].alive);

        y = x;

        case 
            (y.data[choice].kind == Client): {
                case
                    (y.data[choice].state.name == Init): {
                        if (y.data[choice].state.entry) {
                            call (y) = clientInitEntry(choice, x);
                        }
                    }
                    (y.data[choice].state.name == SendPing): {
                        if (y.data[choice].state.entry) {
                            call (y) = clientSendPingEntry(choice, x);
                        }
                    }
                esac
            }
            (y.data[choice].kind == Server): {
                case
                    (y.data[choice].state.name == SendPong): {
                        if (y.data[choice].state.entry) {
                            call (y) = serverSendPongEntry(choice, x);
                        }
                    }
                esac
            }
        esac
    }

    procedure [inline] reactions(x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.count > 0;
        ensures y.count > 0;
    {
        y = x;
    }

    // *** ACTUAL DATA ***
    var machines: machine_list_t;

    // *** TRANSITION SYSTEM ***
    init {
        call (machines) = initMachines();
    }

    next {
        if (*) {
            call (machines') = actions(machines);
        } else {
            call (machines') = reactions(machines);
        }
    }

    // MAIN INVARIANT
    invariant never_bad: 
        forall (id: machine_id) :: (id >= 0 && id < machines.count && machines.data[id].alive) ==> 
            machines.data[id].state.name != Bad;

    // AUXILLARY INVARIANTS
    invariant two_machines_not_in_init_entry_or_one_client_in_init_entry: forall (x: machine_id) ::
        (machines.count == 2 && 
        ((x >= 0 && x < machines.count) ==> 
            machines.data[x].alive && 
            (machines.data[x].state.name != Init || 
            !machines.data[x].state.entry)))
        ||
        (machines.count == 1 && 
         machines.data[0].state.name == Init &&
         machines.data[0].state.entry &&
         machines.data[0].kind == Client && 
         machines.data[0].alive
        );

    control {
        v = induction;
        check;
        print_results;
        v.print_cex(
            machines.count,
            
            machines.data[0].alive,
            machines.data[0].kind,
            machines.data[0].state.name,
            machines.data[0].state.entry,

            machines.data[1].alive,
            machines.data[1].kind,
            machines.data[1].state.name,
            machines.data[1].state.entry
        );
    }
}