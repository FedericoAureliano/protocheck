module main {
    // *** TYPE DECLARATIONS ***
    type machine_id = integer;

    // events
    type signal_t = enum { PING, PONG, SUCCESS };
    type event_t  = record {
        signal: signal_t,
        source: machine_id,
        target: machine_id
    };

    // states
    type state_e = enum { Init, SendPing, WaitPing, WaitPong, SendPong, Bad};
    type state_t = record {
        name : state_e,
        entry: boolean
    };

    // event queues
    type event_id      = integer;
    type count_t       = integer;
    type event_queue_t = record { 
        data: [event_id]event_t,
        head: event_id, 
        tail: event_id,
        size: count_t
    };

    // machines
    type kind_t    = enum { Client, Server };
    type machine_t = record {
        id   : machine_id,
        alive: boolean,
        kind : kind_t,
        state: state_t
    };

    // machine queues
    type machine_list_t = record { 
        data : [machine_id]machine_t,
        count: integer,
        out  : event_queue_t
    };

    // *** PROCEDURE DECLARATIONS ***
    // procedures for event queues
    procedure [inline] resetEvents() 
        returns (q: event_queue_t) 
    {
        q.head  = 0;
        q.tail  = 0;
        q.size = 0;
    }

    procedure [inline] pushEvent(x: event_queue_t, d: event_t) 
        returns (y: event_queue_t) 
    {
        y.data  = x.data[x.tail -> d];
        y.head  = x.head;
        y.tail  = x.tail + 1;
        y.size = x.size + 1;
    }

    procedure [inline] popEvent(x: event_queue_t) 
        returns (y: event_queue_t, popped: event_t) 
        requires x.size > 0;
    {
        y.head  = x.head + 1;
        y.tail  = x.tail;
        y.size = x.size - 1;

        popped = x.data[x.head];
        y.data = x.data;
    }

    //  MACHINES
    procedure [inline] addMachine(x: machine_list_t, d: machine_t) 
        returns (y: machine_list_t) 
        requires d.alive;
        ensures y.count == x.count + 1;
    {
        y = x;

        y.data = x.data[x.count -> d];
        y.count = x.count + 1;
    }

    procedure [inline] getMachine(x: machine_list_t, id: machine_id) 
        returns (m: machine_t) 
        requires x.count > 0;
        requires m.alive;
        ensures m.id == id;
    {
        m = x.data[id];
    }

    procedure [inline] deleteMachine(x: machine_list_t, id: machine_id) 
        returns (y: machine_list_t)
        requires x.count > 0;
        requires x.data[id].alive;
        ensures !y.data[id].alive;
    {
        var m: machine_t;

        m = x.data[id];

        m.alive = false;
        y.data  = x.data[id -> m];
    }

    procedure [inline] initMachines() 
        returns (y: machine_list_t)
        ensures y.count == 1;
        ensures y.data[0].alive;
        ensures y.data[0].kind == Client;
        ensures y.data[0].state.name == Init;
        ensures y.data[0].state.entry;
        ensures y.out.size == 0;
    {
        var client: machine_t;
        var tmp   : machine_list_t;

        tmp.count = 0;

        call (tmp.out) = resetEvents();
        call (client)  = createClient(tmp.count);
        call (y)       = addMachine(tmp, client);
    }

    procedure [inline] createClient(id: machine_id) 
        returns (c: machine_t) 
    {
        c.id          = id;
        c.alive       = true;
        c.kind        = Client;
        c.state.name  = Init;
        c.state.entry = true;
    }

    procedure [inline] createServer(id: machine_id) 
        returns (s: machine_t) 
    {
        s.id          = id;
        s.alive       = true;
        s.kind        = Server;
        s.state.name  = WaitPing;
        s.state.entry = true;
    }

    procedure [inline] gotoBad(id: machine_id, x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.data[id].alive;
        ensures y.data[id].alive;
        ensures y.data[id].kind == x.data[id].kind; 
        ensures y.data[id].state.name == Bad;
        ensures y.count == x.count;
    {
        var m   : machine_t;

        m = x.data[id];
        y = x;
        m.state.name = Bad;
        y.data       = x.data[id -> m];
    }

    procedure [inline] clientInit(e: event_t, x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.data[e.target].alive;
        requires x.data[e.target].kind == Client;
        ensures y.data[e.target].alive;
        ensures y.data[e.target].kind == x.data[e.target].kind; 
        ensures y.count == x.count;
    {
        var m   : machine_t;

        m = x.data[e.target];
        y = x;

        if (e.signal == SUCCESS) {
            m.state.entry = true;
            m.state.name = SendPing;
        } else {
            m.state.name = Bad;
        }

        y.data = x.data[e.target -> m];
    }

    procedure [inline] clientSendPing(e: event_t, x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.data[e.target].alive;
        requires x.data[e.target].kind == Client;
        ensures y.data[e.target].alive;
        ensures y.data[e.target].kind == x.data[e.target].kind; 
        ensures y.count == x.count;
    {
        var m   : machine_t;

        m = x.data[e.target];
        y = x;

        if (e.signal == SUCCESS) {
            m.state.entry = true;
            m.state.name = WaitPong;
        } else {
            m.state.name = Bad;
        }

        y.data = x.data[e.target -> m];
    }

    procedure [inline] clientWaitPong(e: event_t, x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.data[e.target].alive;
        requires x.data[e.target].kind == Client;
        ensures y.data[e.target].alive;
        ensures y.data[e.target].kind == x.data[e.target].kind; 
        ensures y.count == x.count;
    {
        var m   : machine_t;

        m = x.data[e.target];
        y = x;

        if (e.signal == PONG) {
            m.state.entry = true;
            m.state.name = SendPing;
        } else {
            m.state.name = Bad;
        }

        y.data = x.data[e.target -> m];
    }

    procedure [inline] serverSendPong(e: event_t, x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.data[e.target].alive;
        requires x.data[e.target].kind == Server;
        ensures y.data[e.target].alive;
        ensures y.data[e.target].kind == x.data[e.target].kind; 
        ensures y.count == x.count;
    {
        var m   : machine_t;

        m = x.data[e.target];
        y = x;

        if (e.signal == SUCCESS) {
            m.state.entry = true;
            m.state.name = WaitPing;
        } else {
            m.state.name = Bad;
        }

        y.data = x.data[e.target -> m];
    }

    procedure [inline] serverWaitPing(e: event_t, x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.data[e.target].alive;
        requires x.data[e.target].kind == Server;
        ensures y.data[e.target].alive;
        ensures y.data[e.target].kind == x.data[e.target].kind; 
        ensures y.count == x.count;
    {
        var m   : machine_t;

        m = x.data[e.target];
        y = x;

        if (e.signal == PING) {
            m.state.entry = true;
            m.state.name = SendPong;
        } else {
            m.state.name = Bad;
        }

        y.data = x.data[e.target -> m];
    }

    procedure [inline] clientInitEntry(id: machine_id, x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.data[id].alive;
        requires x.data[id].kind == Client; 
        requires x.data[id].state.name == Init; 
        requires x.data[id].state.entry;
        ensures y.data[id].alive;
        ensures y.data[id].kind == Client; 
        ensures y.data[id].state.name == Init; 
        ensures !y.data[id].state.entry;
        ensures y.count == x.count + 1;
    {
        var success: event_t;
        var server : machine_t;
        var client : machine_t;
        var tmp    : machine_list_t;

        client = x.data[id];
        tmp    = x;

        success.signal = SUCCESS;
        success.source = client.id;
        success.target = client.id;

        call (tmp.out)    = pushEvent(x.out, success);
        call (server)     = createServer(x.count);
        call (y)          = addMachine(tmp, server);

        client.state.entry = false;

        y.data = y.data[id -> client];
    }

    procedure [inline] clientSendPingEntry(id: machine_id, x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.data[id].alive;
        requires x.data[id].kind == Client;
        requires x.data[id].state.name == SendPing; 
        requires x.data[id].state.entry;
        ensures y.data[id].alive;
        ensures y.data[id].kind == Client;
        ensures y.data[id].state.name == SendPing; 
        ensures !y.data[id].state.entry;
        ensures y.count == x.count;
        // ensures y.data[id].data[y.data[id].head].signal == PING; //bug in UCLID?
    {
        var success: event_t;
        var ping   : event_t;
        var client : machine_t;
        var tmp1   : machine_list_t;
        var tmp2   : machine_list_t;

        client = x.data[id];

        success.signal = SUCCESS;
        success.source = client.id;
        success.target = client.id;

        tmp1 = x;
        call (tmp1.out) = pushEvent(x.out, success);

        ping.signal       = PING;
        ping.source       = client.id;
        ping.target       = client.id + 1; // better way to do this?

        client.state.entry = false;

        tmp2 = tmp1;
        call (tmp2.out) = pushEvent(tmp1.out, ping);
        y = tmp2;
        y.data = tmp2.data[id -> client];
    }

    procedure [inline] serverSendPongEntry(id: machine_id, x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.data[id].alive;
        requires x.data[id].kind == Server;
        requires x.data[id].state.name == SendPong;
        requires x.data[id].state.entry;
        ensures y.data[id].alive;
        ensures y.data[id].kind == Server;
        ensures y.data[id].state.name == SendPong;
        ensures !y.data[id].state.entry;
        ensures y.count == x.count;
        // ensures y.data[id].data[y.data[id].head].signal == PONG; //bug in UCLID?
    {
        var success: event_t;
        var pong   : event_t;
        var server : machine_t;
        var tmp1   : machine_list_t;
        var tmp2   : machine_list_t;

        server = x.data[id];

        success.signal = SUCCESS;
        success.source = server.id;
        success.target = server.id;

        tmp1 = x;
        call (tmp1.out) = pushEvent(x.out, success);

        pong.signal       = PONG;
        pong.source       = server.id;
        pong.target       = server.id - 1; // better way to do this?

        server.state.entry = false;

        tmp2 = tmp1;
        call (tmp2.out) = pushEvent(tmp1.out, pong);
        y = tmp2;
        y.data = tmp2.data[id -> server];
    }

    procedure [inline] send(x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.count > 0;
        ensures y.count > 0;
    {
        var choice: machine_id;
        assume(choice >= 0 && choice < x.count && x.data[choice].alive);

        y = x;

        case 
            (y.data[choice].kind == Client): {
                case
                    (y.data[choice].state.name == Init): {
                        if (y.data[choice].state.entry) {
                            call (y) = clientInitEntry(choice, x);
                        }
                    }
                    (y.data[choice].state.name == SendPing): {
                        if (y.data[choice].state.entry) {
                            call (y) = clientSendPingEntry(choice, x);
                        }
                    }
                esac
            }
            (y.data[choice].kind == Server): {
                case
                    (y.data[choice].state.name == SendPong): {
                        if (y.data[choice].state.entry) {
                            call (y) = serverSendPongEntry(choice, x);
                        }
                    }
                esac
            }
        esac
    }

    procedure [inline] receive(x: machine_list_t) 
        returns (y: machine_list_t) 
        requires x.out.size > 0;
        ensures y.out.size == x.out.size - 1;
    {
        var e  : event_t;
        var tmp: machine_list_t; 

        tmp = x;
        call (tmp.out, e) = popEvent(x.out);

        // case switch on every state of the entire system
        case 
        (x.data[e.target].state.name == Init) : 
        {
            if (x.data[e.target].kind == Client) {
                if (!x.data[e.target].state.entry) {
                    call (y) = clientInit(e, tmp);
                } else {
                    call (y) = gotoBad(e.target, tmp);
                }
            } else {
                call (y) = gotoBad(e.target, tmp);
            }
        }
        (x.data[e.target].state.name == WaitPong) : 
        {
            if (x.data[e.target].kind == Client) {
                call (y) = clientWaitPong(e, tmp);
            } else {
                call (y) = gotoBad(e.target, tmp);
            }
        }
        (x.data[e.target].state.name == SendPing) : 
        {
            if (x.data[e.target].kind == Client) {
                if (!x.data[e.target].state.entry) {
                    call (y) = clientSendPing(e, tmp);
                } else {
                    call (y) = gotoBad(e.target, tmp);
                }
            } else {
                call (y) = gotoBad(e.target, tmp);
            }
        }
        (x.data[e.target].state.name == WaitPing) : 
        {
            if (x.data[e.target].kind == Server) {
                call (y) = serverWaitPing(e, tmp);
            } else {
                call (y) = gotoBad(e.target, tmp);
            }
        }
        (x.data[e.target].state.name == SendPong) : 
        {
            if (x.data[e.target].kind == Server) {
                if (!x.data[e.target].state.entry) {
                    call (y) = serverSendPong(e, tmp);
                } else {
                    call (y) = gotoBad(e.target, tmp);
                }
            } else {
                call (y) = gotoBad(e.target, tmp);
            }
        }
        esac
    }

    // *** ACTUAL DATA ***
    var machines: machine_list_t;

    // *** TRANSITION SYSTEM ***
    init {
        call (machines) = initMachines();
    }

    next {
        if (*) {
            call (machines') = send(machines);
        } else {
            assume(machines.out.size > 0);
            call (machines') = receive(machines);
        }
    }

    // MAIN INVARIANT
    invariant never_bad: 
        forall (id: machine_id) :: (id >= 0 && id < machines.count && machines.data[id].alive) ==> 
            machines.data[id].state.name != Bad;

    // AUXILLARY INVARIANTS
    invariant two_machines_not_in_init_entry_or_one_client_in_init_entry: forall (x: machine_id) ::
        (machines.count == 2 && 
        ((x >= 0 && x < machines.count) ==> 
            machines.data[x].alive && 
            (machines.data[x].state.name != Init || 
            !machines.data[x].state.entry)))
        ||
        (machines.count == 1 && 
         machines.data[0].state.name == Init &&
         machines.data[0].state.entry &&
         machines.data[0].kind == Client && 
         machines.data[0].alive
        );

    control {
        v = induction;
        check;
        print_results;
        v.print_cex(
            machines.count,
            machines.out.size,
            
            machines.data[0].alive,
            machines.data[0].kind,
            machines.data[0].state.name,
            machines.data[0].state.entry,

            machines.data[1].alive,
            machines.data[1].kind,
            machines.data[1].state.name,
            machines.data[1].state.entry
        );
    }
}