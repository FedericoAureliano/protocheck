module main {
    // *** TYPE DECLARATIONS ***
    type machine_id = integer;

    // events
    type signal_t = enum { PING, PONG, SUCCESS };
    type event_t  = record {
        signal: signal_t,
        source: machine_id,
        target: machine_id
    };

    // states
    type state_e = enum { Init, SendPing, WaitPing, WaitPong, SendPong, Bad};
    type state_t = record {
        name : state_e,
        entry: boolean
    };

    // event queues
    type event_id      = integer;
    type count_t       = integer;
    type event_queue_t = record { 
        data: [event_id]event_t,
        head: event_id, 
        tail: event_id,
        size: count_t
    };

    // machines
    type kind_t    = enum { Client, Server };
    type machine_t = record {
        alive: boolean,
        kind : kind_t,
        state: state_t
    };

    // machine queues
    type machine_list_t = record { 
        data   : [machine_id]machine_t,
        count  : machine_id,
        events : event_queue_t
    };

    // *** PROCEDURE DECLARATIONS ***
    // procedures for event queues
    procedure resetEvents() 
        modifies machines;
    {
        machines.events.head = 0;
        machines.events.tail = 0;
        machines.events.size = 0;
    }

    procedure pushEvent(d: event_t) 
        modifies machines;
    {
        machines.events.data = machines.events.data[machines.events.tail -> d];
        machines.events.tail = machines.events.tail + 1;
        machines.events.size = machines.events.size + 1;
    }

    procedure popEvent() 
        returns (popped: event_t)
        modifies machines; 
    {
        machines.events.head = machines.events.head + 1;
        machines.events.size = machines.events.size - 1;

        popped = machines.events.data[machines.events.head];
        machines.events.data = machines.events.data;
    }

    //  MACHINES
    procedure addMachine(d: machine_t) 
        modifies machines; 
    {
        machines.data  = machines.data[machines.count -> d];
        machines.count = machines.count + 1;
    }

    procedure deleteMachine(id: machine_id) 
        modifies machines;
    {
        var tmp : machine_t;

        tmp = machines.data[id];
        tmp.alive = false;
        machines.data = machines.data[id -> tmp];
    }

    procedure initMachines() 
        modifies machines;
    {
        var c: machine_t;

        call ()  = resetEvents();
        call (c) = createClient();
        call ()  = addMachine(c);
    }

    procedure createClient() 
        returns (c: machine_t)
    {
        c.alive       = true;
        c.kind        = Client;
        c.state.name  = Init;
        c.state.entry = true;
    }

    procedure createServer() 
        returns (s: machine_t)
    {
        s.alive       = true;
        s.kind        = Server;
        s.state.name  = WaitPing;
    }

    procedure gotoBad(id: machine_id) 
        modifies machines;
    {
        var tmp : machine_t;

        tmp = machines.data[id];
        tmp.state.name = Bad;
        machines.data = machines.data[id -> tmp];
    }

    procedure clientInit(e: event_t) 
        modifies machines;
        requires machines.data[e.target].kind == Client;
        requires machines.data[e.target].state.name == Init;
        requires machines.data[e.target].state.entry;
    {
        var tmp : machine_t;
        tmp = machines.data[e.target];

        if (e.signal == SUCCESS) {
            tmp.state.entry = true;
            tmp.state.name = SendPing;
        } else {
            tmp.state.name = Bad;
        }

        machines.data = machines.data[e.target -> tmp];
    }

    procedure clientSendPing(e: event_t) 
        modifies machines;
        requires machines.data[e.target].kind == Client;
        requires machines.data[e.target].state.name == SendPing;
        requires !machines.data[e.target].state.entry;
    {
        var tmp : machine_t;
        tmp = machines.data[e.target];

        if (e.signal == SUCCESS) {
            tmp.state.entry = true;
            tmp.state.name = WaitPong;
        } else {
            tmp.state.name = Bad;
        }

        machines.data = machines.data[e.target -> tmp];
    }

    procedure clientWaitPong(e: event_t) 
        modifies machines;
        requires machines.data[e.target].kind == Client;
        requires machines.data[e.target].state.name == WaitPong;
        requires !machines.data[e.target].state.entry;
    {
        var tmp : machine_t;
        tmp = machines.data[e.target];

        if (e.signal == PONG) {
            tmp.state.entry = true;
            tmp.state.name = SendPing;
        } else {
            tmp.state.name = Bad;
        }

        machines.data = machines.data[e.target -> tmp];
    }

    procedure serverSendPong(e: event_t) 
        modifies machines;
        requires machines.data[e.target].kind == Server;
        requires machines.data[e.target].state.name == SendPong;
        requires !machines.data[e.target].state.entry;
    {
        var tmp : machine_t;
        tmp = machines.data[e.target];

        if (e.signal == SUCCESS) {
            tmp.state.entry = true;
            tmp.state.name = WaitPing;
        } else {
            tmp.state.name = Bad;
        }

        machines.data = machines.data[e.target -> tmp];
    }

    procedure serverWaitPing(e: event_t) 
        modifies machines;
        requires machines.data[e.target].kind == Server;
        requires machines.data[e.target].state.name == WaitPing;
        requires !machines.data[e.target].state.entry;
    {
        var tmp : machine_t;
        tmp = machines.data[e.target];

        if (e.signal == PING) {
            tmp.state.entry = true;
            tmp.state.name = SendPong;
        } else {
            tmp.state.name = Bad;
        }

        machines.data = machines.data[e.target -> tmp];
    }

    procedure clientInitEntry(id: machine_id) 
        modifies machines;
        requires machines.data[id].kind == Client;
        requires machines.data[id].state.name == Init;
        requires machines.data[id].state.entry;
    {
        var success: event_t;
        var s      : machine_t;
        var tmp    : machine_t;

        tmp = machines.data[id];
        tmp.state.entry = false;

        success.signal = SUCCESS;
        success.source = id;
        success.target = id;

        call ()  = pushEvent(success);
        call (s) = createServer();
        call ()  = addMachine(s);

        machines.data = machines.data[id -> tmp];
    }

    procedure clientSendPingEntry(s: machine_id, t: machine_id) 
        modifies machines;
        requires machines.data[s].kind == Client;
        requires machines.data[s].state.name == SendPing;
        requires machines.data[s].state.entry;
    {
        var success: event_t;
        var ping   : event_t;
        var tmp    : machine_t;

        tmp = machines.data[s];
        tmp.state.entry = false;

        success.signal = SUCCESS;
        success.source = s;
        success.target = s;
        call () = pushEvent(success);

        ping.signal = PING;
        ping.source = s;
        ping.target = t;
        call () = pushEvent(ping);

        machines.data = machines.data[s -> tmp];
    }

    procedure serverSendPongEntry(s: machine_id, t: machine_id) 
        modifies machines;
        requires machines.data[s].kind == Server;
        requires machines.data[s].state.name == SendPong;
        requires machines.data[s].state.entry;
    {
        var success: event_t;
        var pong   : event_t;
        var tmp    : machine_t;

        tmp = machines.data[s];
        tmp.state.entry = false;

        success.signal = SUCCESS;
        success.source = s;
        success.target = s;
        call () = pushEvent(success);

        pong.signal = PONG;
        pong.source = s;
        pong.target = t;
        call () = pushEvent(pong);

        machines.data = machines.data[s -> tmp];
    }

    procedure act() 
        modifies machines;
        ensures machines.count == 1 && 
         machines.data[0].state.name == Init &&
         machines.data[0].state.entry &&
         machines.data[0].kind == Client && 
         machines.data[0].alive ==> machines.count == 2 && 
         (machines.data[0].state.name != Init || !machines.data[0].state.entry) &&
         machines.data[0].kind == Client && 
         machines.data[0].alive &&
         machines.data[1].kind == Server &&
         machines.data[1].alive;
    {
        var s: machine_id;
        assume(s >= 0 && s < machines.count && machines.data[s].alive);

        case 
            (machines.data[s].kind == Client): {
                case
                    (machines.data[s].state.name == Init): {
                        if (machines.data[s].state.entry) {
                            call () = clientInitEntry(s);
                        }
                    }
                    (machines.data[s].state.name == SendPing): {
                        if (machines.data[s].state.entry) {
                            var t: machine_id;
                            assume(t >= 0 && t < machines.count && machines.data[t].alive);
                            call () = clientSendPingEntry(s, t);
                        }
                    }
                esac
            }
            (machines.data[s].kind == Server): {
                case
                    (machines.data[s].state.name == SendPong): {
                        if (machines.data[s].state.entry) {
                            var t: machine_id;
                            assume(t >= 0 && t < machines.count && machines.data[t].alive);
                            call () = serverSendPongEntry(s, t);
                        }
                    }
                esac
            }
        esac
    }

    procedure react() 
        modifies machines;
        ensures machines.count == 1 && 
         machines.data[0].state.name == Init &&
         machines.data[0].state.entry &&
         machines.data[0].kind == Client && 
         machines.data[0].alive ==> machines.count == 2 && 
         (machines.data[0].state.name != Init || !machines.data[0].state.entry) &&
         machines.data[0].kind == Client && 
         machines.data[0].alive &&
         machines.data[1].kind == Server &&
         machines.data[1].alive;
    {
        var e  : event_t;

        call (e) = popEvent();

        // case switch on every state of the entire system
        case 
        (machines.data[e.target].state.name == Init) : 
        {
            if (machines.data[e.target].kind == Client) {
                if (!machines.data[e.target].state.entry) {
                    call () = clientInit(e);
                } else {
                    call () = gotoBad(e.target);
                }
            } else {
                call () = gotoBad(e.target);
            }
        }
        (machines.data[e.target].state.name == WaitPong) : 
        {
            if (machines.data[e.target].kind == Client) {
                call () = clientWaitPong(e);
            } else {
                call () = gotoBad(e.target);
            }
        }
        (machines.data[e.target].state.name == SendPing) : 
        {
            if (machines.data[e.target].kind == Client) {
                if (!machines.data[e.target].state.entry) {
                    call () = clientSendPing(e);
                } else {
                    call () = gotoBad(e.target);
                }
            } else {
                call () = gotoBad(e.target);
            }
        }
        (machines.data[e.target].state.name == WaitPing) : 
        {
            if (machines.data[e.target].kind == Server) {
                call () = serverWaitPing(e);
            } else {
                call () = gotoBad(e.target);
            }
        }
        (machines.data[e.target].state.name == SendPong) : 
        {
            if (machines.data[e.target].kind == Server) {
                if (!machines.data[e.target].state.entry) {
                    call () = serverSendPong(e);
                } else {
                    call () = gotoBad(e.target);
                }
            } else {
                call () = gotoBad(e.target);
            }
        }
        (true) : {
            call () = pushEvent(e);
        }
        esac
    }

    // *** ACTUAL DATA ***
    var machines: machine_list_t;

    // *** TRANSITION SYSTEM ***
    init {
        call () = initMachines();
    }

    next {
        if (*) {
            call () = act();
        } else {
            assume(machines.events.size > 0);
            call () = react();
        }
    }

    // MAIN INVARIANT
    invariant never_bad: 
        forall (id: machine_id) :: (id >= 0 && id < machines.count && machines.data[id].alive) ==> 
            machines.data[id].state.name != Bad;

    // AUXILLARY INVARIANTS
    invariant two_machines_not_in_init_entry_or_one_client_in_init_entry:
        (machines.count == 1 && 
         machines.data[0].state.name == Init &&
         machines.data[0].state.entry &&
         machines.data[0].kind == Client && 
         machines.data[0].alive)
        ||
        (machines.count == 2 && 
         (machines.data[0].state.name != Init || !machines.data[0].state.entry) &&
         machines.data[0].kind == Client && 
         machines.data[0].alive &&
         machines.data[1].kind == Server &&
         machines.data[1].alive
         );

    control {
        verify(act);
        verify(react);
        verify(pushEvent);
        verify(popEvent);
        verify(addMachine);
        verify(deleteMachine);
        verify(initMachines);
        verify(gotoBad);
        verify(createClient);
        verify(createServer);
        verify(clientInit);
        verify(clientSendPing);
        verify(clientWaitPong);
        verify(clientInitEntry);
        verify(clientSendPingEntry);
        verify(serverSendPong);
        verify(serverWaitPing);
        verify(serverSendPongEntry);

        v = induction;
        check;
        print_results;

        v.print_cex(
            machines.count,

            machines.events.size,
            machines.events.head,
            machines.events.tail,

            machines.data[0].alive,
            machines.data[0].kind,
            machines.data[0].state.name,
            machines.data[0].state.entry,

            machines.data[1].alive,
            machines.data[1].kind,
            machines.data[1].state.name,
            machines.data[1].state.entry
        );
    }
}