module main {

    type machine_id = integer;

    // events
    type signal_t = enum { PING, PONG, SUCCESS };
    type event_t  = record {
        signal: signal_t,
        source: machine_id,
        target: machine_id
    };

    // states
    type state_e = enum { Init, SendPing, WaitPing, WaitPong, SendPong, Bad};
    type state_t = record {
        name : state_e,
        entry: boolean
    };

    // event queues
    type event_id      = integer;
    type count_t       = integer;
    type event_queue_t = record { 
        data: [event_id]event_t,
        head: event_id, 
        tail: event_id,
        size: count_t
    };

    // machines
    type kind_t    = enum { Client, Server };
    type machine_t = record {
        alive: boolean,
        kind : kind_t,
        state: state_t
    };

    // machine lists
    type machine_list_t = record { 
        data   : [machine_id]machine_t,
        count  : machine_id,
        events : event_queue_t
    };

    // procedures for event queues
    procedure [inline] resetEvents() 
        modifies machines;
    {
        machines.events.head = 0;
        machines.events.tail = 0;
        machines.events.size = 0;
    }

    procedure [inline] pushEvent(event_push: event_t) 
        modifies machines;
    {
        machines.events.data = machines.events.data[machines.events.tail -> event_push];
        machines.events.tail = machines.events.tail + 1;
        machines.events.size = machines.events.size + 1;
    }

    procedure [inline] popEvent() 
        returns (event_pop: event_t)
        modifies machines; 
    {
        machines.events.head = machines.events.head + 1;
        machines.events.size = machines.events.size - 1;

        event_pop = machines.events.data[machines.events.head];
        machines.events.data = machines.events.data;
    }

    //  procedures for machine lists
    procedure [inline] resetMachines() 
        modifies machines;
    {
        machines.count = 0;
    }

    procedure [inline] addMachine(machine_add: machine_t) 
        modifies machines; 
    {
        machines.data  = machines.data[machines.count -> machine_add];
        machines.count = machines.count + 1;
    }

    procedure [inline] deleteMachine(id_delete: machine_id) 
        modifies machines;
    {
        var tmp_delete : machine_t;

        tmp_delete       = machines.data[id_delete];
        tmp_delete.alive = false;
        machines.data    = machines.data[id_delete -> tmp_delete];
    }

    // procedures for the model
    procedure [inline] initMachines() 
        modifies machines;
    {
        var client_init: machine_t;

        call ()            = resetMachines();
        call ()            = resetEvents();
        call (client_init) = createClient();
        call ()            = addMachine(client_init);
    }

    procedure [inline] createClient() 
        returns (client_create: machine_t)
    {
        client_create.alive       = true;
        client_create.kind        = Client;
        client_create.state.name  = Init;
        client_create.state.entry = true;
    }

    procedure [inline] createServer() 
        returns (server_create: machine_t)
    {
        server_create.alive       = true;
        server_create.kind        = Server;
        server_create.state.name  = WaitPing;
    }

    procedure [inline] gotoBad(id: machine_id) 
        modifies machines;
    {
        var tmp_bad : machine_t;

        tmp_bad            = machines.data[id];
        tmp_bad.state.name = Bad;
        machines.data      = machines.data[id -> tmp_bad];
    }

    procedure [inline] clientInit(client_init_event: event_t) 
        modifies machines;
        requires machines.data[client_init_event.target].kind == Client;
        requires machines.data[client_init_event.target].state.name == Init;
        requires !machines.data[client_init_event.target].state.entry;
    {
        var tmp_client_init : machine_t;
        tmp_client_init = machines.data[client_init_event.target];

        if (client_init_event.signal == SUCCESS) {
            tmp_client_init.state.entry = true;
            tmp_client_init.state.name = SendPing;
        } else {
            tmp_client_init.state.name = Bad;
        }

        machines.data = machines.data[client_init_event.target -> tmp_client_init];
    }

    procedure [inline] clientSendPing(client_send_ping_event: event_t) 
        modifies machines;
        requires machines.data[client_send_ping_event.target].kind == Client;
        requires machines.data[client_send_ping_event.target].state.name == SendPing;
        requires !machines.data[client_send_ping_event.target].state.entry;
    {
        var tmp_client_send_ping : machine_t;
        tmp_client_send_ping = machines.data[client_send_ping_event.target];

        if (client_send_ping_event.signal == SUCCESS) {
            tmp_client_send_ping.state.entry = true;
            tmp_client_send_ping.state.name = WaitPong;
        } else {
            tmp_client_send_ping.state.name = Bad;
        }

        machines.data = machines.data[client_send_ping_event.target -> tmp_client_send_ping];
    }

    procedure [inline] clientWaitPong(client_wait_pong_event: event_t) 
        modifies machines;
        requires machines.data[client_wait_pong_event.target].kind == Client;
        requires machines.data[client_wait_pong_event.target].state.name == WaitPong;
    {
        var tmp_client_wait_pong : machine_t;
        tmp_client_wait_pong = machines.data[client_wait_pong_event.target];

        if (client_wait_pong_event.signal == PONG) {
            tmp_client_wait_pong.state.entry = true;
            tmp_client_wait_pong.state.name = SendPing;
        } else {
            tmp_client_wait_pong.state.name = Bad;
        }

        machines.data = machines.data[client_wait_pong_event.target -> tmp_client_wait_pong];
    }

    procedure [inline] serverSendPong(server_send_pong_event: event_t) 
        modifies machines;
        requires machines.data[server_send_pong_event.target].kind == Server;
        requires machines.data[server_send_pong_event.target].state.name == SendPong;
        requires !machines.data[server_send_pong_event.target].state.entry;
    {
        var tmp_server_send_pong : machine_t;
        tmp_server_send_pong = machines.data[server_send_pong_event.target];

        if (server_send_pong_event.signal == SUCCESS) {
            tmp_server_send_pong.state.entry = true;
            tmp_server_send_pong.state.name = WaitPing;
        } else {
            tmp_server_send_pong.state.name = Bad;
        }

        machines.data = machines.data[server_send_pong_event.target -> tmp_server_send_pong];
    }

    procedure [inline] serverWaitPing(server_wait_ping_event: event_t) 
        modifies machines;
        requires machines.data[server_wait_ping_event.target].kind == Server;
        requires machines.data[server_wait_ping_event.target].state.name == WaitPing;
    {
        var tmp_server_wait_ping : machine_t;
        tmp_server_wait_ping = machines.data[server_wait_ping_event.target];

        if (server_wait_ping_event.signal == PING) {
            tmp_server_wait_ping.state.entry = true;
            tmp_server_wait_ping.state.name = SendPong;
        } else {
            tmp_server_wait_ping.state.name = Bad;
        }

        machines.data = machines.data[server_wait_ping_event.target -> tmp_server_wait_ping];
    }

    procedure [inline] clientInitEntry(client_init_entry_id: machine_id) 
        modifies machines;
        requires machines.data[client_init_entry_id].kind == Client;
        requires machines.data[client_init_entry_id].state.name == Init;
        requires machines.data[client_init_entry_id].state.entry;
    {
        var init_success_event    : event_t;
        var new_server            : machine_t;
        var tmp_client_init_entry : machine_t;

        tmp_client_init_entry = machines.data[client_init_entry_id];
        tmp_client_init_entry.state.entry = false;

        init_success_event.signal = SUCCESS;
        init_success_event.source = client_init_entry_id;
        init_success_event.target = client_init_entry_id;

        call ()           = pushEvent(init_success_event);
        call (new_server) = createServer();
        call ()           = addMachine(new_server);

        machines.data = machines.data[client_init_entry_id -> tmp_client_init_entry];
    }

    procedure [inline] clientSendPingEntry(send_ping_source_id: machine_id, send_ping_target_id: machine_id) 
        modifies machines;
        requires machines.data[send_ping_source_id].kind == Client;
        requires machines.data[send_ping_source_id].state.name == SendPing;
        requires machines.data[send_ping_source_id].state.entry;
    {
        var send_ping_success_event : event_t;
        var send_ping_event         : event_t;
        var tmp_send_ping           : machine_t;

        tmp_send_ping             = machines.data[send_ping_source_id];
        tmp_send_ping.state.entry = false;

        send_ping_success_event.signal = SUCCESS;
        send_ping_success_event.source = send_ping_source_id;
        send_ping_success_event.target = send_ping_source_id;
        call () = pushEvent(send_ping_success_event);

        send_ping_event.signal = PING;
        send_ping_event.source = send_ping_source_id;
        send_ping_event.target = send_ping_target_id;
        call () = pushEvent(send_ping_event);

        machines.data = machines.data[send_ping_source_id -> tmp_send_ping];
    }

    procedure [inline] serverSendPongEntry(send_pong_source_id: machine_id, send_pong_target_id: machine_id) 
        modifies machines;
        requires machines.data[send_pong_source_id].kind == Server;
        requires machines.data[send_pong_source_id].state.name == SendPong;
        requires machines.data[send_pong_source_id].state.entry;
    {
        var send_pong_success_event : event_t;
        var send_pong_event         : event_t;
        var tmp_send_pong           : machine_t;

        tmp_send_pong             = machines.data[send_pong_source_id];
        tmp_send_pong.state.entry = false;

        send_pong_success_event.signal = SUCCESS;
        send_pong_success_event.source = send_pong_source_id;
        send_pong_success_event.target = send_pong_source_id;
        call () = pushEvent(send_pong_success_event);

        send_pong_event.signal = PONG;
        send_pong_event.source = send_pong_source_id;
        send_pong_event.target = send_pong_target_id;
        call () = pushEvent(send_pong_event);

        machines.data = machines.data[send_pong_source_id -> tmp_send_pong];
    }

    procedure [inline] act() 
        modifies machines;
    {
        var s: machine_id;
        assume(s >= 0 && s < machines.count && machines.data[s].alive);

        case 
            (machines.data[s].kind == Client): {
                case
                    (machines.data[s].state.name == Init): {
                        if (machines.data[s].state.entry) {
                            call () = clientInitEntry(s);
                        }
                    }
                    (machines.data[s].state.name == SendPing): {
                        if (machines.data[s].state.entry) {
                            var t: machine_id;
                            assume(t >= 0 && t < machines.count && machines.data[t].alive);
                            call () = clientSendPingEntry(s, t);
                        }
                    }
                esac
            }
            (machines.data[s].kind == Server): {
                case
                    (machines.data[s].state.name == SendPong): {
                        if (machines.data[s].state.entry) {
                            var t: machine_id;
                            assume(t >= 0 && t < machines.count && machines.data[t].alive);
                            call () = serverSendPongEntry(s, t);
                        }
                    }
                esac
            }
        esac
    }

    procedure [inline] react() 
        modifies machines;
    {
        var e  : event_t;

        call (e) = popEvent();

        // case switch on every state of the entire system
        case 
        (machines.data[e.target].state.name == Init) : 
        {
            if (machines.data[e.target].kind == Client) {
                if (!machines.data[e.target].state.entry) {
                    call () = clientInit(e);
                } else {
                    call () = gotoBad(e.target);
                }
            } else {
                call () = gotoBad(e.target);
            }
        }
        (machines.data[e.target].state.name == WaitPong) : 
        {
            if (machines.data[e.target].kind == Client) {
                call () = clientWaitPong(e);
            } else {
                call () = gotoBad(e.target);
            }
        }
        (machines.data[e.target].state.name == SendPing) : 
        {
            if (machines.data[e.target].kind == Client) {
                if (!machines.data[e.target].state.entry) {
                    call () = clientSendPing(e);
                } else {
                    call () = gotoBad(e.target);
                }
            } else {
                call () = gotoBad(e.target);
            }
        }
        (machines.data[e.target].state.name == WaitPing) : 
        {
            if (machines.data[e.target].kind == Server) {
                call () = serverWaitPing(e);
            } else {
                call () = gotoBad(e.target);
            }
        }
        (machines.data[e.target].state.name == SendPong) : 
        {
            if (machines.data[e.target].kind == Server) {
                if (!machines.data[e.target].state.entry) {
                    call () = serverSendPong(e);
                } else {
                    call () = gotoBad(e.target);
                }
            } else {
                call () = gotoBad(e.target);
            }
        }
        (true) : {
            call () = pushEvent(e);
        }
        esac
    }

    var machines: machine_list_t;

    init {
        call () = initMachines();
    }

    next {
        if (*) {
            call () = act();
        } else {
            assume(machines.events.size > 0);
            assume(machines.count > 1);
            call () = react();
        }
    }

    // MAIN INVARIANT
    invariant never_bad: 
        forall (id: machine_id) :: (id >= 0 && id < machines.count && machines.data[id].alive) ==> 
            machines.data[id].state.name != Bad;

    // AUXILLARY INVARIANTS
    invariant two_machines_not_in_init_entry_or_one_client_in_init_entry:
        (machines.count == 1 && 
         machines.data[0].state.name == Init &&
         machines.data[0].state.entry &&
         machines.data[0].kind == Client && 
         machines.data[0].alive)
        ||
        (machines.count == 2 && 
         (machines.data[0].state.name != Init || !machines.data[0].state.entry) &&
         machines.data[0].kind == Client && 
         machines.data[0].alive &&
         machines.data[1].kind == Server &&
         machines.data[1].alive
         );
    
    invariant max_two_events: machines.events.size <= 2;
    invariant min_zero_events: machines.events.size >= 0;
    invariant coherent_events: 
        machines.events.size == machines.events.tail - machines.events.head;

    invariant send_ping_entry_then_events_empty: 
        machines.data[0].state.name == SendPing &&
        machines.data[0].state.entry &&
        machines.data[0].kind == Client ==> machines.events.size == 0;

    invariant init_entry_then_events_empty: 
        machines.data[0].state.name == Init &&
        machines.data[0].state.entry &&
        machines.data[0].kind == Client ==> machines.events.size == 0;

    invariant init_then_one_event_success: 
        machines.data[0].state.name == Init &&
        machines.data[0].kind == Client ==> 
        machines.events.size == 1 ==> 
        machines.events.data[machines.events.head].target == 0;

    invariant send_pong_entry_then_events_empty: 
        machines.count > 1 &&
        machines.data[1].state.name == SendPong &&
        machines.data[1].state.entry &&
        machines.data[1].kind == Server ==> machines.events.size == 0;

    invariant send_ping_means_wait_ping: 
        machines.data[0].kind == Client &&  
        machines.data[0].state.name == SendPing &&
        machines.data[0].state.entry ==>
        ((machines.data[1].kind == Server &&
        machines.data[1].state.name == WaitPing) ||
        (machines.data[1].kind == Server &&
        machines.data[1].state.name == SendPong &&
        !machines.data[1].state.entry));

    invariant init_means_wait_ping: 
        machines.count > 1 ==>
        machines.data[0].kind == Client &&  
        machines.data[0].state.name == Init ==>
        (machines.data[1].kind == Server &&
        machines.data[1].state.name == WaitPing);

    invariant send_pong_means_wait_pong: 
        machines.data[0].kind == Server &&  
        machines.data[0].state.name == SendPong &&
        machines.data[0].state.entry ==>
        ((machines.data[1].kind == Client &&
        machines.data[1].state.name == WaitPong) ||
        (machines.data[1].kind == Client &&
        machines.data[1].state.name == SendPing &&
        !machines.data[1].state.entry));

    invariant server_wait_or_send:
        machines.count > 1 ==>
        machines.data[1].kind == Server &&
        (machines.data[1].state.name == WaitPing || 
        machines.data[1].state.name == SendPong); 

    invariant client_init_send_or_wait:
        machines.data[0].kind == Client &&
        (machines.data[0].state.name == WaitPong || 
        machines.data[0].state.name == SendPing ||
        machines.data[0].state.name == Init); 

    control {
        v = induction;
        check;
        print_results;

        v.print_cex(
            machines.count,

            machines.events.size,
            machines.events.head,
            machines.events.tail,

            machines.data[0].alive,
            machines.data[0].kind,
            machines.data[0].state.name,
            machines.data[0].state.entry,

            machines.data[1].alive,
            machines.data[1].kind,
            machines.data[1].state.name,
            machines.data[1].state.entry
        );
    }
}