module main {

    type machine_id = integer;

    // events
    type signal_t = enum { PING, PONG, SUCCESS };
    type event_t  = record {
        signal: signal_t,
        source: machine_id,
        target: machine_id
    };

    // states
    type state_e = enum { Init, SendPing, WaitPing, WaitPong, SendPong, Bad};
    type state_t = record {
        name : state_e,
        entry: boolean
    };

    // event queues
    type event_id      = integer;
    type event_queue_t = record { 
        data: [event_id]event_t,
        head: event_id, 
        tail: event_id,
        size: event_id
    };

    // machines
    type kind_t    = enum { Client, Server };
    type machine_t = record {
        alive: boolean,
        kind : kind_t,
        state: state_t
    };

    // machine lists
    type machine_list_t = record { 
        data  : [machine_id]machine_t,
        count : machine_id,
        events: event_queue_t
    };

    // Define shortcuts
    define m_count () : machine_id  = machines.count;
    define e_head  () : event_id    = machines.events.head;
    define e_tail  () : event_id    = machines.events.tail;
    define e_count () : event_id    = machines.events.size;
    define get    (id : machine_id) : machine_t = machines.data[id];
    define kind   (id : machine_id) : kind_t    = machines.data[id].kind;
    define state  (id : machine_id) : state_e   = machines.data[id].state.name;
    define entry  (id : machine_id) : boolean   = machines.data[id].state.entry;
    define alive  (id : machine_id) : boolean   = id >= 0 && id < machines.count && machines.data[id].alive;
    define valid  (id : event_id)   : boolean   = id >= e_head() && id < e_tail();

    // procedures for event queues
    procedure [inline] resetEvents() 
        modifies machines;
    {
        machines.events.head = 0;
        machines.events.tail = 0;
        machines.events.size = 0;
    }

    procedure [inline] pushEvent(e: event_t) 
        modifies machines;
    {
        machines.events.data = machines.events.data[e_tail() -> e];
        machines.events.tail = e_tail() + 1;
        machines.events.size = e_count() + 1;
    }

    procedure [inline] popEvent() 
        returns (e: event_t)
        modifies machines; 
    {
        e = machines.events.data[e_head()];
        machines.events.head = e_head() + 1;
        machines.events.size = e_count() - 1;
    }

    //  procedures for machine lists
    procedure [inline] resetMachines() 
        modifies machines;
    {
        machines.count = 0;
    }

    procedure [inline] addMachine(m: machine_t) 
        modifies machines; 
    {
        machines.data  = machines.data[m_count() -> m];
        machines.count = m_count() + 1;
    }

    procedure [inline] deleteMachine(id: machine_id) 
        modifies machines;
    {
        var tmp : machine_t;

        tmp           = get(id);
        tmp.alive     = false;
        machines.data = machines.data[id -> tmp];
    }

    // procedures for the model
    procedure [inline] initMachines() 
        modifies machines;
    {
        var tmp: machine_t;

        call ()    = resetMachines();
        call ()    = resetEvents();
        call (tmp) = createClient();
        call ()    = addMachine(tmp);
    }

    procedure [inline] createClient() 
        returns (client: machine_t)
    {
        client.alive       = true;
        client.kind        = Client;
        client.state.name  = Init;
        client.state.entry = true;
    }

    procedure [inline] createServer() 
        returns (server: machine_t)
    {
        server.alive       = true;
        server.kind        = Server;
        server.state.name  = WaitPing;
    }

    procedure [inline] clientInit(e: event_t) 
        modifies machines;
        requires kind(e.target) == Client;
        requires state(e.target) == Init;
        requires !entry(e.target);
    {
        var tmp : machine_t;
        tmp = get(e.target); 

        if (e.signal == SUCCESS) {
            tmp.state.entry = true;
            tmp.state.name = SendPing;
        } else {
            tmp.state.name = Bad;
        }

        machines.data = machines.data[e.target -> tmp];
    }

    procedure [inline] clientSendPing(e: event_t) 
        modifies machines;
        requires kind(e.target) == Client;
        requires state(e.target) == SendPing;
        requires !entry(e.target);
    {
        var tmp : machine_t;
        tmp = get(e.target);

        if (e.signal == SUCCESS) {
            tmp.state.entry = true;
            tmp.state.name = WaitPong;
        } else {
            tmp.state.name = Bad;
        }

        machines.data = machines.data[e.target -> tmp];
    }

    procedure [inline] clientWaitPong(e: event_t) 
        modifies machines;
        requires kind(e.target) == Client;
        requires state(e.target) == WaitPong;
    {
        var tmp : machine_t;
        tmp = get(e.target);

        if (e.signal == PONG) {
            tmp.state.entry = true;
            tmp.state.name = SendPing;
        } else {
            tmp.state.name = Bad;
        }

        machines.data = machines.data[e.target -> tmp];
    }

    procedure [inline] serverSendPong(e: event_t) 
        modifies machines;
        requires kind(e.target) == Server;
        requires state(e.target) == SendPong;
        requires !entry(e.target);
    {
        var tmp : machine_t;
        tmp = get(e.target);

        if (e.signal == SUCCESS) {
            tmp.state.entry = true;
            tmp.state.name = WaitPing;
        } else {
            tmp.state.name = Bad;
        }

        machines.data = machines.data[e.target -> tmp];
    }

    procedure [inline] serverWaitPing(e: event_t) 
        modifies machines;
        requires kind(e.target) == Server;
        requires state(e.target) == WaitPing;
    {
        var tmp : machine_t;
        tmp = get(e.target);

        if (e.signal == PING) {
            tmp.state.entry = true;
            tmp.state.name = SendPong;
        } else {
            tmp.state.name = Bad;
        }

        machines.data = machines.data[e.target -> tmp];
    }

    procedure [inline] clientInitEntry(id: machine_id) 
        modifies machines;
        requires kind(id) == Client;
        requires state(id) == Init;
        requires entry(id);
    {
        var e      : event_t;
        var server : machine_t;
        var tmp    : machine_t;

        tmp = get(id);
        tmp.state.entry = false;

        e.signal = SUCCESS;
        e.source = id;
        e.target = id;

        call ()       = pushEvent(e);
        call (server) = createServer();
        call ()       = addMachine(server);

        machines.data = machines.data[id -> tmp];
    }

    procedure [inline] clientSendPingEntry(source: machine_id, target: machine_id) 
        modifies machines;
        requires kind(source) == Client;
        requires state(source) == SendPing;
        requires entry(source);
    {
        var success : event_t;
        var ping    : event_t;
        var tmp     : machine_t;

        tmp             = get(source);
        tmp.state.entry = false;

        success.signal = SUCCESS;
        success.source = source;
        success.target = source;
        call () = pushEvent(success);

        ping.signal = PING;
        ping.source = source;
        ping.target = target;
        call () = pushEvent(ping);

        machines.data = machines.data[source -> tmp];
    }

    procedure [inline] serverSendPongEntry(source: machine_id, target: machine_id) 
        modifies machines;
        requires kind(source) == Server;
        requires state(source) == SendPong;
        requires entry(source);
    {
        var success : event_t;
        var pong    : event_t;
        var tmp     : machine_t;

        tmp             = get(source);
        tmp.state.entry = false;

        success.signal = SUCCESS;
        success.source = source;
        success.target = source;
        call () = pushEvent(success);

        pong.signal = PONG;
        pong.source = source;
        pong.target = target;
        call () = pushEvent(pong);

        machines.data = machines.data[source -> tmp];
    }

    procedure [inline] act() 
        modifies machines;
    {
        var s: machine_id;
        assume(alive(s));

        case 
            (kind(s) == Client): {
                case
                (state(s) == Init): {
                       if (entry(s)) {
                            call () = clientInitEntry(s);
                        }
                    }
                (state(s) == SendPing): {
                       if (entry(s)) {
                            var t: machine_id;
                            assume(alive(t) && t != s);
                            call () = clientSendPingEntry(s, t);
                        }
                    }
                (true) : {
                    // do nothings
                }
                esac
            }
            (kind(s) == Server): {
                case
                (state(s) == SendPong): {
                       if (entry(s)) {
                            var t: machine_id;
                            assume(alive(t) && t != s);
                            call () = serverSendPongEntry(s, t);
                        }
                    }
                (true) : {
                    // do nothings
                }
                esac
            }
        (true) : {
            // do nothings
        }
        esac
    }

    procedure [inline] react() 
        modifies machines;
    {
        var e  : event_t;

        call (e) = popEvent();

        // case switch on every state of the entire system
        case 
        (kind(e.target) == Client) : {
            case 
            (state(e.target) == Init) : {
                if (!entry(e.target)) {
                    call () = clientInit(e);
                }
            }
            (state(e.target) == WaitPong) : {
                call () = clientWaitPong(e);
            }
            (state(e.target) == SendPing) : {
                if (!entry(e.target)) {
                    call () = clientSendPing(e);
                }
            }
            (true) : {
                // do nothing
            }
            esac
        } 
        (kind(e.target) == Server) : {
            case 
            (state(e.target) == WaitPing) : {
                call () = serverWaitPing(e);
            }
            (state(e.target) == SendPong) : {
                if (!entry(e.target)) {
                    call () = serverSendPong(e);
                }
            }
            (true) : {
                // do nothing
            }
            esac
        }
        (true) : {
            // do nothing
        }
        esac
    }

    var machines: machine_list_t;

    init {
        call () = initMachines();
    }

    next {
        if (*) {
            call () = act();
        } else {
            assume(e_count() > 0);
            call () = react();
        }
    }

    // MAIN INVARIANT
    invariant never_bad: 
        forall (id: machine_id) :: alive(id) ==> state(id) != Bad;

    // AUXILLARY INVARIANTS

    // first machine is client, second is server, if it exists
    invariant two_machines_not_in_init_entry_or_one_client_in_init_entry:
        (m_count() == 1 && 
         state(0) == Init &&
         entry(0) &&
         kind(0) == Client && 
         alive(0))
        ||
        (m_count() == 2 && 
         (state(0) != Init || !entry(0)) &&
         kind(0) == Client && 
         alive(0) &&
         kind(1) == Server &&
         alive(1)
         );
    
    invariant max_two_events: e_count() <= 2;
    invariant min_zero_events: e_count() >= 0;
    invariant coherent_events: e_count() == e_tail() - e_head();

    // every target exists 
    invariant existing_target: 
        forall (x : event_id) :: valid(x) ==>
            (machines.events.data[x].target >= 0 && machines.events.data[x].target < machines.count);

    // client is in Init, SendPing, or WaitPong
    invariant client_states: 
        state(0) == Init ||
        state(0) == SendPing ||
        state(0) == WaitPong;

    // server is in SendPong, or WaitPing, if it exists
    invariant server_states: m_count() == 2 ==> 
        (state(1) == SendPong || state(1) == WaitPing);

    invariant cant_both_send: state(0) != SendPing || state(1) != SendPong;

    // If the client is in init, then the server is in WaitPing, if it exists
    invariant client_init: state(0) == Init ==>
        (m_count() == 2 ==> state(1) == WaitPing);

    // If the client is in init entry, then the server doesn't exist and events are empty
    invariant client_init_entry: (state(0) == Init && entry(0)) ==>
        (m_count() == 1 && e_count() == 0);

    // If the client is in init but not entry, then the server exists and success is the only event
    invariant client_init_success: (state(0) == Init && !entry(0)) ==>
        (m_count() == 2 && e_count() == 1 &&
        machines.events.data[e_head()].signal == SUCCESS &&
        machines.events.data[e_head()].target == 0);

    // If the client is in SendPing entry then there are no events 
    invariant client_send_ping_entry: (state(0) == SendPing && entry(0)) ==> e_count() == 0;

    // If the client is in SendPing not entry and the server is in WaitPing, then there are two events: success and ping 
    invariant client_send_ping_not_entry: (state(0) == SendPing && !entry(0) && state(1) == WaitPing) ==>
        (e_count() == 2 && 
        machines.events.data[e_head()].signal == SUCCESS &&
        machines.events.data[e_head()].target == 0 &&
        machines.events.data[e_head() + 1].signal == PING &&
        machines.events.data[e_head() + 1].target == 1);

    // If the client is waiting for a pong, then there is a single pong event or a success before it
    invariant client_wait_pong: state(1) == WaitPong ==>
        (e_count() == 2 ==>
        (machines.events.data[e_head()].signal == SUCCESS &&
        machines.events.data[e_head()].target == 1 &&
        machines.events.data[e_head() + 1].signal == PONG &&
        machines.events.data[e_head() + 1].target == 0));

    // If the server is in SendPong entry then there are no events 
    invariant server_send_pong_entry: (state(1) == SendPong && entry(1)) ==> e_count() == 0;

    // If the server is in SendPong not entry and the client is in WaitPong, then there are two events: success and ping 
    invariant server_send_pong_not_entry:
        (state(1) == SendPong &&
        !entry(1) &&
        state(0) == WaitPong) ==>
        (e_count() == 2 && 
        machines.events.data[e_head()].signal == SUCCESS &&
        machines.events.data[e_head()].target == 1 &&
        machines.events.data[e_head() + 1].signal == PONG &&
        machines.events.data[e_head() + 1].target == 0);

    // If the server is waiting for a ping, then there is a single ping event or a success before it
    invariant server_wait_ping: state(1) == WaitPing ==>
        (e_count() == 2 ==>
        (machines.events.data[e_head()].signal == SUCCESS &&
        machines.events.data[e_head()].target == 0 &&
        machines.events.data[e_head() + 1].signal == PING &&
        machines.events.data[e_head() + 1].target == 1));

    invariant wait_wait_1: (state(0) == WaitPong && state(1) == WaitPing) ==>
        (e_count() == 1 &&
        ((machines.events.data[e_head()].signal == PING &&
        machines.events.data[e_head()].target == 1) ||
        ((machines.events.data[e_head()].signal == PONG &&
        machines.events.data[e_head()].target == 0))));

    control {
        v = induction;
        check;
        print_results;

        v.print_cex(
            machines.count,

            machines.events.size,
            machines.events.data[machines.events.head].signal,
            machines.events.data[machines.events.head].target,
            machines.events.data[machines.events.head+1].signal,
            machines.events.data[machines.events.head+1].target,

            machines.data[0].kind,
            machines.data[0].state.name,
            machines.data[0].state.entry,

            machines.data[1].kind,
            machines.data[1].state.name,
            machines.data[1].state.entry
        );
    }
}