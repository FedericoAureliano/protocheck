module main {
    // *** TYPE DECLARATIONS ***
    type machine_id = integer;

    // events
    type signal_t = enum { PING, PONG, SUCCESS };
    type event_t = record {
        signal : signal_t,
        source : machine_id,
        target : machine_id
    };

    // states
    type state_e = enum { Init, SendPing, WaitPing, WaitPong, SendPong, Bad};
    type state_t = record {
        name  : state_e,
        entry : boolean
    };

    // event queues
    type event_id = integer;
    type count_t = integer;
    type event_queue_t = record { 
        contents : [event_id]event_t,
        head     : event_id, 
        tail     : event_id, 
        count    : count_t
    };

    // machines
    type kind_t = enum { Client, Server };
    type machine_t = record {
        kind   : kind_t,
        state  : state_t,
        id     : machine_id,
        out    : event_queue_t
    };

    // machine queues
    type machine_list_t = record { 
        contents : [machine_id]machine_t,
        head     : machine_id,
        tail     : machine_id,
        count    : count_t
    };

    // *** PROCEDURE DECLARATIONS ***
    // procedures for machine queues
    procedure [inline] pushMachine(in_q : machine_list_t, d: machine_t) returns (out_q : machine_list_t) {
        out_q.contents = in_q.contents[in_q.tail -> d];
        out_q.head = in_q.head;
        out_q.tail = in_q.tail + 1;
        out_q.count = in_q.count + 1;
    }

    procedure [inline] popMachine(in_q : machine_list_t) returns (out_q : machine_list_t, popped: machine_t) 
        requires in_q.count > 0;
    {
        out_q.head = in_q.head + 1;
        out_q.tail = in_q.tail;
        out_q.count = in_q.count - 1;

        popped = in_q.contents[in_q.head];
        out_q.contents = in_q.contents;
    }


    // procedures for event queues
    procedure [inline] resetEvents() returns (q : event_queue_t) {
        q.head   = 0;
        q.tail   = 0;
        q.count  = 0;
    }

    procedure [inline] pushEvent(in_q : event_queue_t, d: event_t) returns (out_q : event_queue_t) {
        out_q.contents = in_q.contents[in_q.tail -> d];
        out_q.head = in_q.head;
        out_q.tail = in_q.tail + 1;
        out_q.count = in_q.count + 1;
    }

    procedure [inline] popEvent(in_q : event_queue_t) returns (out_q : event_queue_t, popped: event_t) 
        requires in_q.count > 0;
    {
        out_q.head = in_q.head + 1;
        out_q.tail = in_q.tail;
        out_q.count = in_q.count - 1;

        popped = in_q.contents[in_q.head];
        out_q.contents = in_q.contents;
    }

    // helpers for transition
    procedure [inline] initMachines() returns (q : machine_list_t) {
        var client : machine_t;

        q.head   = 0;
        q.tail   = 0;
        q.count  = 0;

        call (client) = createClient(q.count);
        call (q) = pushMachine(q, client);
    }

    procedure [inline] createClient(id : machine_id) returns (c : machine_t) {
        c.kind = Client;
        c.state.name = Init;
        c.state.entry = true;
        c.id = id;
        call (c.out) = resetEvents();
    }

    procedure [inline] createServer(id : machine_id) returns (s : machine_t) {
        s.kind = Server;
        s.state.name = WaitPing;
        s.state.entry = true;
        s.id = id;
        call (s.out) = resetEvents();
    }

    // THE DRIVER TRANSITION PROCEDURE
    procedure [inline] step(old : machine_list_t) returns (new : machine_list_t) 
        requires old.count > 0;
        ensures new.count > 0;
    {
        var m : machine_t;
        call (new, m) = popMachine(old);

        case 
            (m.kind == Client) : {
                case
                    (m.state.name == Init) : {
                        if (m.state.entry) {
                            var success : event_t;
                            var server : machine_t;

                            success.signal = SUCCESS;
                            success.source = m.id;
                            success.target = m.id;
                            call (m.out) = pushEvent(m.out, success);

                            call (server) = createServer(old.count);
                            call (new) = pushMachine(new, server);

                            m.state.entry = false;
                        }
                    }
                    (m.state.name == SendPing) : {
                        if (m.state.entry) {
                            var success : event_t;
                            var ping : event_t;

                            success.signal = SUCCESS;
                            success.source = m.id;
                            success.target = m.id;
                            call (m.out) = pushEvent(m.out, success);

                            ping.signal = PING;
                            ping.source = m.id;
                            ping.target = if (m.id == 0) then 1 else 0;
                            call (m.out) = pushEvent(m.out, ping);

                            m.state.entry = false;
                        }
                    }
                esac
            }
            (m.kind == Server) : {

            }
        esac

        call (new) = pushMachine(new, m);
    }

    // *** ACTUAL DATA ***
    var machines : machine_list_t;

    // *** TRANSITION SYSTEM ***
    init {
        call (machines) = initMachines();
    }

    next {
        call (machines') = step(machines);
    }

    // MAIN INVARIANT
    invariant never_bad : 
        forall (id : machine_id) :: (id >= machines.head && id < machines.tail) ==> 
            machines.contents[id].state.name != Bad;

    // AUXILLARY INVARIANTS
    invariant two_machines_not_in_init_entry_or_one_client_in_init_entry : forall (x : machine_id) ::
        (machines.count == 2 && 
        ((x >= machines.head && x < machines.tail) ==> 
            (machines.contents[x].state.name != Init || 
            !machines.contents[x].state.entry)))
        ||
        (machines.count == 1 && 
         machines.contents[machines.head].state.name == Init &&
         machines.contents[machines.head].state.entry &&
         machines.contents[machines.head].kind == Client
        );

    invariant machine_list_head_and_tail : machines.tail == machines.head + machines.count;

    invariant unique_id : 
        forall (x : machine_id) :: 
        forall (y : machine_id) :: (
                x != y && 
                x >= machines.head && x < machines.tail && 
                y >= machines.head && y < machines.tail
            ) ==> 
                machines.contents[x].id != machines.contents[y].id;

    invariant one_machine_id_0 : machines.count == 1 ==> machines.contents[machines.head].id == 0;

    control {
        v = induction;
        check;
        print_results;
        v.print_cex(
            machines.count,
            machines.head,
            machines.tail,
            
            machines.contents[machines.head].kind,
            machines.contents[machines.head].id,
            machines.contents[machines.head].state.name,
            machines.contents[machines.head].state.entry,

            machines.contents[machines.head+1].kind,
            machines.contents[machines.head+1].id,
            machines.contents[machines.head+1].state.name,
            machines.contents[machines.head+1].state.entry
        );
    }
}