module Common {

    define peek() : event_t = event_queue.events[event_queue.head];

    type machine_id = integer;

    const coordinator_id : machine_id;
    axiom coordinator_id == 0;

    const participant_i : machine_id;
    const participant_j : machine_id;
    axiom participant_i != participant_j;
    axiom participant_i > 0 && participant_i <= participant_count;
    axiom participant_j > 0 && participant_j <= participant_count;

    const participant_count : machine_id;
    axiom participant_count > 2;

    type event_id   = integer;
    type signal_t = enum { 
        EWRITETRANSACTION,
         EPREPARESUCCESS,
         EPREPAREFAIL,
         EPREPARE,
         EGLOBALCOMMIT,
         EGLOBALABORT
    };

    type event_t  = record {
        signal: signal_t,
        source: machine_id,
        target: machine_id,
        data: integer
    };

    type event_q = record { 
        events  : [event_id]event_t,
        head  : event_id, 
        tail  : event_id,
        size  : event_id
    };

    procedure [inline] reset_events() 
        modifies event_queue;
    {
        event_queue.head = 0;
        event_queue.tail = 0;
        event_queue.size = 0;
    }

    procedure [inline] push_event(e: event_t) 
        modifies event_queue;
    {
        event_queue.events = event_queue.events[event_queue.tail -> e];
        event_queue.tail = event_queue.tail + 1;
        event_queue.size = event_queue.size + 1;
    }

    procedure [inline] pop_event() 
        returns (e: event_t)
        modifies event_queue;  
    {
        e = event_queue.events[event_queue.head];
        event_queue.head = event_queue.head + 1;
        event_queue.size = event_queue.size - 1;
    }

    sharedvar event_queue : event_q;
}


module Coordinator {

    define peek() : event_t = queue.events[queue.head];
    define e_valid(id : event_id) : boolean = id >= queue.head && id < queue.tail && queue.size > 0;

    type * = Common.*;
    type state_t = enum {
        WAITFORTRANSACTIONS, 
        WAITFORPREPARERESPONSES
    };

    var state : state_t;
    var entry : boolean;
    var countPrepareResponses : integer;

    sharedvar queue : event_q;
    sharedvar active: boolean;

    instance common : Common (event_queue : (queue));

    procedure [inline] coordinator_WaitForTransactions()
        modifies state, entry, common;
        requires peek().target == Common.coordinator_id;
        requires state == WAITFORTRANSACTIONS;
        requires (forall (x : integer) :: (e_valid(x) && queue.events[x].target > Common.coordinator_id) ==>
                    (queue.events[x].signal == EPREPARE || 
                     queue.events[x].signal == EGLOBALCOMMIT || 
                     queue.events[x].signal == EGLOBALABORT));
        ensures (forall (x : integer) :: (e_valid(x) && queue.events[x].target > Common.coordinator_id) ==>
                    (queue.events[x].signal == EPREPARE || 
                     queue.events[x].signal == EGLOBALCOMMIT || 
                     queue.events[x].signal == EGLOBALABORT));
    {
        var e : event_t;
        call (e) = common.pop_event();

        if (e.signal == EWRITETRANSACTION) { 
            var x : integer;
            x = 1;
            while (x <= Common.participant_count)
                invariant x >= 1;
                invariant (forall (x : integer) :: (e_valid(x) && queue.events[x].target > Common.coordinator_id) ==>
                    (queue.events[x].signal == EPREPARE || 
                     queue.events[x].signal == EGLOBALCOMMIT || 
                     queue.events[x].signal == EGLOBALABORT));
            {
                var w : event_t;
                w.target = x;
                w.source = Common.coordinator_id; 
                w.signal = EPREPARE;
                w.data = e.data;
                call () = common.push_event(w);
                x = x + 1;
            }
            entry = true;
            state = WAITFORPREPARERESPONSES;
        }
    }

    procedure [inline] coordinator_WaitForPrepareResponses()
        modifies state, entry, countPrepareResponses, common;
        requires peek().target == Common.coordinator_id;
        requires peek().signal == EPREPARESUCCESS || peek().signal == EPREPAREFAIL;
        requires state == WAITFORPREPARERESPONSES;
        requires (forall (x : integer) :: (e_valid(x) && queue.events[x].target > Common.coordinator_id) ==>
                    (queue.events[x].signal == EPREPARE || 
                     queue.events[x].signal == EGLOBALCOMMIT || 
                     queue.events[x].signal == EGLOBALABORT));
        ensures (forall (x : integer) :: (e_valid(x) && queue.events[x].target > Common.coordinator_id) ==>
                    (queue.events[x].signal == EPREPARE || 
                     queue.events[x].signal == EGLOBALCOMMIT || 
                     queue.events[x].signal == EGLOBALABORT));
    {
        var e : event_t;
        call (e) = common.pop_event();
        if (entry) {
            countPrepareResponses = 0;
            entry = false;
        }
        case
        (e.signal == EPREPARESUCCESS) : {
            countPrepareResponses = countPrepareResponses + 1;
            if (countPrepareResponses == Common.participant_count) {
                var x : integer;
                x = 1;
                while (x <= Common.participant_count)
                    invariant x >= 1;
                    invariant (forall (y : integer) :: (y >= 1 && y < x) ==> (exists (z : integer) :: (e_valid(z) && queue.events[z].target == y && queue.events[z].signal == EGLOBALCOMMIT)));
                {
                    var w : event_t;
                    w.target = x;
                    w.source = Common.coordinator_id; 
                    w.signal = EGLOBALCOMMIT;
                    call () = common.push_event(w);
                    x = x + 1;
                }
                entry = true;
                state = WAITFORTRANSACTIONS;
                countPrepareResponses = 0;
            }
        }
        (e.signal == EPREPAREFAIL) : {
            var x : integer;
            x = 1;
            while (x <= Common.participant_count)
                invariant x >= 1;
                invariant (forall (y : integer) :: (y >= 1 && y < x) ==> (exists (z : integer) :: (e_valid(z) && queue.events[z].target == y && queue.events[z].signal == EGLOBALABORT)));
            {
                var w : event_t;
                w.target = x;
                w.source = Common.coordinator_id; 
                w.signal = EGLOBALABORT;
                call () = common.push_event(w);
                x = x + 1;
            }
            entry = true;
            state = WAITFORTRANSACTIONS;
            countPrepareResponses = 0;
        }
        esac
    }

    init {
        call () = common.reset_events();
        state = WAITFORTRANSACTIONS;
        entry = true;
        countPrepareResponses = 0;
        active = false;
    }

    next {
        if (active && queue.size > 0 && peek().target == Common.coordinator_id) {
            case
            (state == WAITFORTRANSACTIONS) : {
                // assume(peek().signal == EWRITETRANSACTION);
                call () = coordinator_WaitForTransactions();
            }
            (state == WAITFORPREPARERESPONSES) : {
                // assume(peek().signal == EPREPARESUCCESS || peek().signal == EPREPAREFAIL);
                call () = coordinator_WaitForPrepareResponses();
            }
            esac
        }
    }

    invariant coherent_events: queue.size >= 0 && queue.size == queue.tail - queue.head;

    invariant participant_events: (forall (x : integer) :: (e_valid(x) && queue.events[x].target > Common.coordinator_id) ==>
                    (queue.events[x].signal == EPREPARE || 
                     queue.events[x].signal == EGLOBALCOMMIT || 
                     queue.events[x].signal == EGLOBALABORT));

    control {
        verify(coordinator_WaitForTransactions);
        verify(coordinator_WaitForPrepareResponses);
        v = induction;
        check;
        print_results;
        v.print_cex(
            queue.size,
            queue.events,
            state
        );
    }
}


module Participant {

    define peek() : event_t = queue.events[queue.head];

    type * = Common.*;
    type state_t = enum {WAITFORREQUESTS};

    var state : state_t;
    var entry : boolean;
    var writes: integer;
    var memory: [integer]integer;
    
    var id : integer;
    
    sharedvar queue : event_q;
    sharedvar active: boolean;

    instance common : Common (event_queue : (queue));

    procedure [inline] participant_WaitForRequests()
        modifies state, entry, writes, memory, common;
        requires peek().signal == EPREPARE || peek().signal == EGLOBALCOMMIT || peek().signal == EGLOBALABORT;
        requires peek().target == id;
        requires state == WAITFORREQUESTS;
    {
        var e : event_t;
        call (e) = common.pop_event();
        case 
        (e.signal == EPREPARE) : {
            var w : event_t;
            w.target = Common.coordinator_id;
            w.source = e.target; 
            if (*) {
                memory = memory[writes -> e.data];
                w.signal = EPREPARESUCCESS;
                call () = common.push_event(w); 
            } else {
                w.signal = EPREPAREFAIL;
                call () = common.push_event(w);  
            }
        }
        (e.signal == EGLOBALCOMMIT) : {
            writes = writes + 1;
        }
        (e.signal == EGLOBALABORT) : {
        }
        esac 
    }

    init {
        call () = common.reset_events();
        state = WAITFORREQUESTS;
        entry = true;
        writes = 0;
        active = false;
    }

    next {
        if (active && queue.size > 0 && peek().target == id) {
            case
            (state == WAITFORREQUESTS) : {
                // assume(peek().signal == EPREPARE || peek().signal == EGLOBALCOMMIT || peek().signal == EGLOBALABORT);
                call () = participant_WaitForRequests();
            }
            esac
        }
    }

    invariant coherent_events: queue.size >= 0 && queue.size == queue.tail - queue.head;

    control {
        v = induction;
        check;
        print_results;
        v.print_cex(
            queue.size,
            queue.head,
            queue.tail,
            queue.events[queue.head].source,
            queue.events[queue.head].target,
            queue.events[queue.head].signal,
            queue.events[queue.tail - 1].source,
            queue.events[queue.tail - 1].target,
            queue.events[queue.tail - 1].signal,

            state
        );
    }
}

module Rest {

    define peek() : event_t = queue.events[queue.head];

    type * = Common.*;
    
    sharedvar queue : event_q;
    sharedvar active: boolean;

    instance common : Common (event_queue : (queue));

    procedure [inline] rest_WaitForRequests()
        modifies common;
        requires peek().target > Common.coordinator_id; 
        requires peek().target != Common.participant_i; 
        requires peek().target != Common.participant_j; 
        requires peek().target <= Common.participant_count;
    {
        var e : event_t;
        call (e) = common.pop_event();
        case 
        (e.signal == EPREPARE) : {
            var w : event_t;
            w.target = Common.coordinator_id;
            w.source = e.target;
            if (*) {
                w.signal = EPREPARESUCCESS;
                call () = common.push_event(w); 
            } else {
                w.signal = EPREPAREFAIL;
                call () = common.push_event(w);
            }
        }
        esac 
    }

    init {
        call () = common.reset_events();
        active = false;
    }

    next {
        if (active && queue.size > 0 && peek().target > Common.coordinator_id && 
                peek().target != Common.participant_i && 
                peek().target != Common.participant_j &&
                peek().target <= Common.participant_count)
        {
            // assume(peek().signal == EPREPARE || peek().signal == EGLOBALCOMMIT || peek().signal == EGLOBALABORT);
            call () = rest_WaitForRequests();
        }
    }

    invariant coherent_events: queue.size >= 0 && queue.size == queue.tail - queue.head;

    control {
        v = induction;
        check;
        print_results;
        v.print_cex(
            queue.size,
            queue.head,
            queue.tail,
            queue.events[queue.head].source,
            queue.events[queue.head].target,
            queue.events[queue.head].signal,
            queue.events[queue.tail - 1].source,
            queue.events[queue.tail - 1].target,
            queue.events[queue.tail - 1].signal
        );
    }
}

module main {

    define peek() : event_t = queue.events[queue.head];

    type * = Common.*;
    type coordinator_state_t = Coordinator.state_t;
    type participant_state_t = Participant.state_t;
    
    var queue : event_q;
    var active_c : boolean;
    var active_r : boolean;
    var active_i : boolean;
    var active_j : boolean;

    define e_valid(id : event_id) : boolean = id >= queue.head && id < queue.tail && queue.size > 0;

    instance c : Coordinator (queue : (queue), active : (active_c));
    instance r : Rest        (queue : (queue), active : (active_r));
    instance i : Participant (queue : (queue), active : (active_i));
    instance j : Participant (queue : (queue), active : (active_j));

    instance common : Common (event_queue : (queue));

    init {
        queue.size = 0;
        queue.head = 0;
        queue.tail = 0;
        assume(c.state == WAITFORTRANSACTIONS);
        assume(i.id == Common.participant_i);
        assume(i.writes == 0);
        assume(j.id == Common.participant_j);
        assume(j.writes == 0);
        assume(c.countPrepareResponses == 0);
        active_c = true;
        active_i = false;
        active_j = false;
        active_r = false;
    }

    next {
        if (queue.size == 0 && c.state == WAITFORTRANSACTIONS) {
            var e : event_t;
            assume(e.target == Common.coordinator_id);
            assume(e.signal == EWRITETRANSACTION);
            assume(e.source == -1);
            call () = common.push_event(e);
        }
        case
        (active_c) : {
            next(c);
        }
        (active_i) : {
            next(i);
        }
        (active_j) : {
            next(j);
        }
        (active_r) : {
            next(r);
        }
        esac

        havoc active_c;
        havoc active_i;
        havoc active_j;
        havoc active_r;
        assume(active_c || active_i || active_j || active_r);
        assume(active_c ==> (!active_i && !active_j && !active_r));
        assume(active_i ==> (!active_c && !active_j && !active_r));
        assume(active_j ==> (!active_i && !active_c && !active_r));
        assume(active_r ==> (!active_i && !active_j && !active_c));
    }

    invariant same_memory: (forall (x : integer) :: (x >= 0 && x < i.writes || x < j.writes) 
        ==> i.memory[x] == j.memory[x]);

    // auxilary invariants
    invariant close_writes: i.writes == j.writes || i.writes == j.writes + 1 || i.writes + 1 == j.writes;
    invariant sync_writes: (c.state == WAITFORTRANSACTIONS && queue.size == 0) ==> i.writes == j.writes;
    invariant i_behind_means_i_commit: i.writes < j.writes ==> 
        ((exists (x : integer) :: e_valid(x) && 
            queue.events[x].signal == EGLOBALCOMMIT && 
            queue.events[x].target == Common.participant_i) &&
        (i.memory[i.writes] == j.memory[i.writes]) &&
        (forall (y : integer) :: e_valid(y) ==> 
            queue.events[y].target != Common.participant_j)
        );
    invariant j_behind_means_j_commit: j.writes < i.writes ==> 
        ((exists (x : integer) :: e_valid(x) && 
            queue.events[x].signal == EGLOBALCOMMIT && 
            queue.events[x].target == Common.participant_j) &&
        (j.memory[j.writes] == i.memory[j.writes]) &&
        (forall (y : integer) :: e_valid(y) ==> 
            queue.events[y].target != Common.participant_i)
        );

    invariant even_means_both_or_neither_commit: i.writes == j.writes ==>
        (((exists (x : integer) :: e_valid(x) && 
            queue.events[x].signal == EGLOBALCOMMIT && 
            queue.events[x].target == Common.participant_j) && 
           (exists (x : integer) :: e_valid(x) && 
            queue.events[x].signal == EGLOBALCOMMIT && 
            queue.events[x].target == Common.participant_i)) ||
         (forall (y : integer) :: e_valid(y) ==> 
           ((queue.events[y].target != Common.participant_i && queue.events[y].target != Common.participant_j) || queue.events[y].signal != EGLOBALCOMMIT)));

    // unique_commits: 
    assume((forall (x : integer, y : integer) :: 
        (e_valid(x) && e_valid(y) && queue.events[y].target == queue.events[x].target && queue.events[y].signal == EGLOBALCOMMIT && queue.events[x].signal == EGLOBALCOMMIT) ==> 
        x == y));

    // one_write_transaction_at_a_time
    assume((forall (x : integer, y : integer) :: 
        (e_valid(x) && e_valid(y) && queue.events[y].signal == EWRITETRANSACTION && queue.events[x].signal == EWRITETRANSACTION) ==> 
        x == y));

    invariant only_ever_single_write :
        (exists (x : integer) :: (e_valid(x) && 
            queue.events[x].signal == EWRITETRANSACTION)) ==> queue.size == 1;

    invariant no_abort_means_no_more_events_than_can_count: 
        ((forall (y : integer) :: e_valid(y) ==> 
           (queue.events[y].signal != EGLOBALABORT)) ==> queue.size <= Common.participant_count - c.countPrepareResponses) || (queue.size  == 1 && peek().signal == EWRITETRANSACTION);

    invariant no_abort_before_prep: 
        (exists (x : integer) :: (e_valid(x) && 
            queue.events[x].signal == EGLOBALABORT) ==> 
                (forall (y: integer) :: (y > x && e_valid(y)) ==> (queue.events[x].signal != EPREPARE)));

    invariant abort_always_last: 
        (exists (x : integer) :: (e_valid(x) && 
            queue.events[x].signal == EGLOBALABORT)) ==> 
                (forall (y: integer) :: (y >= queue.tail || queue.events[y].signal == EGLOBALABORT));

    invariant count_range : c.countPrepareResponses >= 0 && c.countPrepareResponses <= Common.participant_count;
    // invariant nothing_to_wait_for : c.countPrepareResponses == Common.participant_count ==> (c.state == WAITFORTRANSACTIONS || c.entry);
    invariant wait_means_no_count: c.state == WAITFORTRANSACTIONS ==> c.countPrepareResponses == 0;


    invariant not_commit_and_abort:
        (exists (x : integer) :: e_valid(x) && 
            queue.events[x].signal == EGLOBALCOMMIT) ==>
        (forall (y : integer) :: e_valid(y) ==> 
            queue.events[y].signal != EGLOBALABORT);

    invariant below_count_means_no_commit: c.countPrepareResponses < Common.participant_count ==>
        (forall (y : integer) :: e_valid(y) ==> 
            queue.events[y].signal != EGLOBALCOMMIT);

    invariant abort_means_equal:
        (exists (x : integer) :: e_valid(x) && 
            queue.events[x].signal == EGLOBALABORT) ==> i.writes == j.writes;

    invariant abort_means_wait_trans: 
        (exists (x : integer) :: (e_valid(x) && 
            queue.events[x].signal == EGLOBALABORT)) ==> c.state == WAITFORTRANSACTIONS;

    invariant commit_means_wait_trans: 
        (exists (x : integer) :: (e_valid(x) && 
            queue.events[x].signal == EGLOBALCOMMIT)) ==> c.state == WAITFORTRANSACTIONS;

    // Assumptions from submodules and message passing
    assume(active_c && queue.size > 0 ==> peek().target == Common.coordinator_id);
    assume(active_i && queue.size > 0 ==> peek().target == Common.participant_i);
    assume(active_j && queue.size > 0 ==> peek().target == Common.participant_j);
    assume(active_r && queue.size > 0 ==> (peek().target > Common.coordinator_id && peek().target <= Common.participant_count));

    assume(forall (x : integer, y : integer) :: 
        (e_valid(x) && e_valid(y) && queue.events[x].signal == EPREPARE &&  queue.events[y].signal == EPREPARE) ==>
            (queue.events[x].data == queue.events[y].data));

    assume(queue.size >= 0 && queue.size == queue.tail - queue.head);
    assume(queue.head >= 0);

    assume((exists (x : integer) :: e_valid(x) && 
            queue.events[x].signal == EWRITETRANSACTION && 
            queue.events[x].target == Common.coordinator_id) ==>
                (queue.size == 1));

    assume((forall (x : integer) :: (c.state == WAITFORPREPARERESPONSES && e_valid(x) && queue.events[x].target == Common.coordinator_id) ==>
                    (queue.events[x].signal == EPREPARESUCCESS || 
                     queue.events[x].signal == EPREPAREFAIL)));

    assume((forall (x : integer) :: (e_valid(x) && queue.events[x].target > Common.coordinator_id) ==>
                    (queue.events[x].signal == EPREPARE || 
                     queue.events[x].signal == EGLOBALCOMMIT || 
                     queue.events[x].signal == EGLOBALABORT)));

    assume((forall (x : integer) :: (e_valid(x) && queue.events[x].signal == EPREPARE) ==>
                    (queue.events[x].target > Common.coordinator_id)));

    assume((forall (x : integer) :: (e_valid(x) && queue.events[x].signal == EGLOBALCOMMIT) ==>
                    (queue.events[x].target > Common.coordinator_id)));
        
    assume((forall (x : integer) :: (e_valid(x) && queue.events[x].signal == EGLOBALABORT) ==>
                    (queue.events[x].target > Common.coordinator_id)));

    assume(i.id > Common.coordinator_id && i.id <= Common.participant_count && 
                   j.id > Common.coordinator_id && j.id <= Common.participant_count &&
                   i.id != j.id &&
                   Common.coordinator_id == 0);

    assume(i.writes >= 0 && j.writes >= 0);

    control {
        v = induction;
        check;
        print_results;
        v.print_cex(
            Common.participant_i,
            Common.participant_j,
            Common.participant_count,

            c.state,
            c.entry,
            c.countPrepareResponses,

            queue.size,
            queue.head,
            queue.tail,
            queue.events,

            i.writes,
            j.writes,
            i.memory,
            j.memory
        );
    }
}