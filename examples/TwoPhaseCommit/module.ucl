module Common {

    type machine_id = integer;

    const coordinator_id : machine_id;
    axiom coordinator_id == 0;
    const participant_i : machine_id;
    const participant_j : machine_id;
    axiom participant_i != participant_j;

    const participant_count : machine_id;
    axiom participant_count > 2;

    type event_id   = integer;
    type signal_t = enum { 
        EWRITETRANSACTION,
         EPREPARESUCCESS,
         EPREPAREFAIL,
         EPREPARE,
         EGLOBALCOMMIT,
         EGLOBALABORT
    };

    type event_t  = record {
        signal: signal_t,
        source: machine_id,
        target: machine_id,
        data: integer
    };

    type event_q = record { 
        events  : [event_id]event_t,
        head  : event_id, 
        tail  : event_id,
        size  : event_id
    };

    procedure [inline] reset_events() 
        modifies event_queue;
    {
        event_queue.head = 0;
        event_queue.tail = 0;
        event_queue.size = 0;
    }

    procedure [inline] push_event(e: event_t) 
        modifies event_queue;
    {
        event_queue.events = event_queue.events[event_queue.tail -> e];
        event_queue.tail = event_queue.tail + 1;
        event_queue.size = event_queue.size + 1;
    }

    procedure [inline] pop_event() 
        returns (e: event_t)
        modifies event_queue;  
    {
        e = event_queue.events[event_queue.head];

        event_queue.head = event_queue.head + 1;
        event_queue.size = event_queue.size - 1;
    }

    sharedvar event_queue : event_q;

    init {
        call () = reset_events();
    }

    next {
        if (*) {
            var e : event_t;
            call () = push_event(e);
        } else {
            var e : event_t;
            assume(event_queue.size > 0);

            call (e) = pop_event();
        }
    }

    invariant coherent_events: event_queue.size == event_queue.tail - event_queue.head;

    control {
        v = induction;
        check;
        print_results;
    }
}


module Coordinator {
    type * = Common.*;
    type state_t = enum {
        WAITFORTRANSACTIONS, 
        WAITFORPREPARERESPONSES
    };

    var state : state_t;
    var entry : boolean;
    var countPrepareResponses : integer;

    sharedvar queue : event_q;

    instance common : Common (event_queue : (queue));

    procedure [inline] pop_event() 
        returns (e: event_t)
        modifies queue;  
    {
        e = queue.events[queue.head];

        queue.head = queue.head + 1;
        queue.size = queue.size - 1;
    }

    procedure [inline] coordinator_WaitForTransactions(e: event_t)
        modifies state, entry, common;
        requires e.target == Common.coordinator_id;
        requires e.signal == EWRITETRANSACTION;
        requires state == WAITFORTRANSACTIONS;
    {
        if (e.signal == EWRITETRANSACTION) { 
            var x : integer;
            x = 1;
            while (x <= Common.participant_count)
                invariant x >= 1;
                invariant queue.size >= 0 && queue.size == queue.tail - queue.head;
            {
                var w : event_t;
                w.target = x;
                w.source = Common.coordinator_id; 
                w.signal = EPREPARE;
                w.data = e.data;
                call () = common.push_event(w);
                x = x + 1;
            }
            entry = true;
            state = WAITFORPREPARERESPONSES;
        }
    }

    procedure [inline] coordinator_WaitForPrepareResponses(e: event_t)
        modifies state, entry, countPrepareResponses, common;
        requires e.target == Common.coordinator_id;
        requires e.signal == EPREPARESUCCESS || e.signal == EPREPAREFAIL;
        requires state == WAITFORPREPARERESPONSES;
    {
        if (entry) {
            countPrepareResponses = 0;
            entry = false;
        }
        case
        (e.signal == EPREPARESUCCESS) : {
            countPrepareResponses = countPrepareResponses + 1;
            if (countPrepareResponses == Common.participant_count) {
                var x : integer;
                x = 1;
                while (x <= Common.participant_count)
                    invariant x >= 1;
                    invariant queue.size >= 0 && queue.size == queue.tail - queue.head;
                {
                    var w : event_t;
                    w.target = x;
                    w.source = Common.coordinator_id; 
                    w.signal = EGLOBALCOMMIT;
                    call () = common.push_event(w);
                    x = x + 1;
                }
                entry = true;
                state = WAITFORTRANSACTIONS;
            }
        }
        (e.signal == EPREPAREFAIL) : {
            var x : integer;
            x = 1;
            while (x <= Common.participant_count)
                invariant x >= 1;
                invariant queue.size >= 0 && queue.size == queue.tail - queue.head;
            {
                var w : event_t;
                w.target = x;
                w.source = Common.coordinator_id; 
                w.signal = EGLOBALABORT;
                call () = common.push_event(w);
                x = x + 1;
            }
            entry = true;
            state = WAITFORTRANSACTIONS;
        }
        esac
    }

    init {
        call () = common.reset_events();
        state = WAITFORTRANSACTIONS;
        entry = true;
        countPrepareResponses = 0;
    }

    next {
        var e : event_t;
        assume e.target == Common.coordinator_id;
        assume e.signal == EWRITETRANSACTION;
        case
        (state == WAITFORTRANSACTIONS && entry) : {
            call () = coordinator_WaitForTransactions(e);
        }
        esac
    }

    invariant coherent_events: queue.size >= 0 && queue.size == queue.tail - queue.head;

    control {
        v = induction;
        check;
        print_results;
        v.print_cex(
            queue.size,
            queue.head,
            queue.tail,
            queue.events[queue.head].source,
            queue.events[queue.head].target,
            queue.events[queue.head].signal,
            queue.events[queue.tail - 1].source,
            queue.events[queue.tail - 1].target,
            queue.events[queue.tail - 1].signal,

            state
        );
    }
}


module Participant {
    type * = Common.*;
    type state_t = enum {WAITFORREQUESTS};

    var state : state_t;
    var entry : boolean;
    var writes: integer;
    var memory: [integer]integer;
    
    sharedvar queue : event_q;

    instance common : Common (event_queue : (queue));

    procedure [inline] participant_WaitForRequests(e: event_t)
        modifies state, entry, writes, memory, common;
        requires e.signal == EPREPARE || e.signal == EGLOBALCOMMIT || e.signal == EGLOBALABORT;

        requires e.target > Common.coordinator_id && e.target <= Common.participant_count;
        requires state == WAITFORREQUESTS;
    {
        case 
        (e.signal == EPREPARE) : {
            var w : event_t;
            w.target = Common.coordinator_id;
            w.source = e.target; 
            if (*) {
                memory = memory[writes -> e.data];
                w.signal = EPREPARESUCCESS;
                call () = common.push_event(w); 
            } else {
                w.signal = EPREPAREFAIL;
                call () = common.push_event(w);  
            }
        }
        (e.signal == EGLOBALCOMMIT) : {
            writes = writes + 1;
        }
        (e.signal == EGLOBALABORT) : {
            
        }
        esac 
    }

    init {
        call () = common.reset_events();
        state = WAITFORREQUESTS;
        entry = true;
        writes = 0;
    }

    next {

    }

    invariant coherent_events: queue.size >= 0 && queue.size == queue.tail - queue.head;

    control {
        v = induction;
        check;
        print_results;
        v.print_cex(
            queue.size,
            queue.head,
            queue.tail,
            queue.events[queue.head].source,
            queue.events[queue.head].target,
            queue.events[queue.head].signal,
            queue.events[queue.tail - 1].source,
            queue.events[queue.tail - 1].target,
            queue.events[queue.tail - 1].signal,

            state
        );
    }
}

module Rest {
    type * = Common.*;
    
    sharedvar queue : event_q;

    instance common : Common (event_queue : (queue));

    procedure [inline] rest_WaitForRequests(e: event_t)
        modifies common;
        requires e.target > Common.coordinator_id && e.target <= Common.participant_count;
    {
        case 
        (e.signal == EPREPARE) : {
            var w : event_t;
            w.target = Common.coordinator_id;
            w.source = e.target;
            if (*) {
                w.signal = EPREPARESUCCESS;
                call () = common.push_event(w); 
            } else {
                w.signal = EPREPAREFAIL;
                call () = common.push_event(w);
            }
        }
        esac 
    }

    init {
        call () = common.reset_events();
    }

    next {
        
    }

    invariant coherent_events: queue.size >= 0 && queue.size == queue.tail - queue.head;

    control {
        v = induction;
        check;
        print_results;
        v.print_cex(
            queue.size,
            queue.head,
            queue.tail,
            queue.events[queue.head].source,
            queue.events[queue.head].target,
            queue.events[queue.head].signal,
            queue.events[queue.tail - 1].source,
            queue.events[queue.tail - 1].target,
            queue.events[queue.tail - 1].signal
        );
    }
}

module main {

    type * = Common.*;
    type coordinator_state_t = Coordinator.state_t;
    type participant_state_t = Participant.state_t;
    
    var queue : event_q;

    instance c : Coordinator (queue : (queue));
    instance r : Rest        (queue : (queue));
    instance i : Participant (queue : (queue));
    instance j : Participant (queue : (queue));

    procedure [inline] communicate() 
        modifies r, i, j, c; //important: cannot modify queue here!
    {
        if (queue.size > 0) {
            var e: event_t;
            call (e) = c.pop_event();

            case 
            (e.target == Common.coordinator_id) : {
                case 
                (c.state == WAITFORPREPARERESPONSES) : {
                    call () = c.coordinator_WaitForPrepareResponses(e);
                }
                esac
            } 
            (e.target == Common.participant_i) : {
                case 
                (i.state == WAITFORREQUESTS) : {
                    call () = i.participant_WaitForRequests(e);
                }
                esac
            }
            (e.target == Common.participant_j) : {
                case 
                (j.state == WAITFORREQUESTS) : {
                    call () = j.participant_WaitForRequests(e);
                }
                esac
            }
            (e.target <= Common.participant_count && e.target > 0) : {
                call () = r.rest_WaitForRequests(e);
            }
            esac
        }
    }

    init {
        queue.size = 0;
        queue.head = 0;
        queue.tail = 0;
        assume(c.state == WAITFORTRANSACTIONS);
        assume(i.writes == 0);
        assume(j.writes == 0);
    }

    next {
        if (*) {
            assume(queue.size > 0);
            call () = communicate();
        } else {
            if (*) {
                next(c);
            } else {
                if (*) {
                    next(i);
                } else {
                    if (*) {
                        next(j);
                    } else {
                        next(r);
                    }
                }
            }
        }
    }

    invariant same_memory: (forall (x : integer) :: (x >= 0 && x < i.writes && x < j.writes) 
        ==> i.memory[x] == j.memory[x]);

    control {
        v = induction;
        check;
        print_results;
        v.print_cex(
            c.state,
            c.entry,
            i.state,
            i.entry,
            j.state,
            j.entry,
            queue.size,
            queue.events[queue.head].signal,
            queue.events[queue.head].target
        );
    }
}